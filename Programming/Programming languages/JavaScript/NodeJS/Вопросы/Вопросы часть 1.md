17-04-2023
08:59
Authors: 
***
Tags: #nodeJS
***
# Ячейки 2-101

## Когда следует использовать базу данных NoSQL вместо реляционной базы данных?
Вам следует рассмотреть возможность использования базы данных NoSQL вместо реляционной базы данных, когда:

1.  У вас есть большие объемы неструктурированных или полуструктурированных данных: базы данных NoSQL предназначены для обработки больших объемов неструктурированных или полуструктурированных данных, что делает их идеальными для таких случаев использования, как социальные сети, Интернет вещей и анализ данных в реальном времени.
    
2.  Вам нужна горизонтальная масштабируемость: базы данных NoSQL можно легко масштабировать горизонтально, добавляя дополнительные серверы, что сложно сделать с традиционными реляционными базами данных. Это делает базы данных NoSQL хорошо подходящими для приложений с высокими требованиями к масштабируемости.
    
3.  У вас есть гибкая схема данных: в отличие от реляционных баз данных, базы данных NoSQL не имеют строгой схемы, поэтому вы можете легко добавлять новые поля или изменять существующие, не требуя миграции. Это облегчает адаптацию к изменяющимся требованиям и обработку данных, которые постоянно развиваются.
    
4.  Вам нужна высокая доступность и отказоустойчивость: базы данных NoSQL спроектированы так, чтобы быть высокодоступными и отказоустойчивыми, что делает их хорошим выбором для приложений, которым требуется постоянное время безотказной работы и минимальное время простоя.

При этом важно отметить, что базы данных NoSQL не являются панацеей, и при их использовании есть компромиссы. Например, базы данных NoSQL могут не так подходить для сложных транзакций и запросов, как реляционные базы данных. В конечном итоге выбор между NoSQL и реляционной базой данных зависит от ваших конкретных требований и варианта использования.

## В чем разница между репликацией и шардингом в Redis?
Репликация и сегментирование — это два разных способа горизонтального масштабирования Redis для обработки больших наборов данных и более высоких нагрузок трафика.

Репликация в Redis включает создание копий одного и того же экземпляра Redis на нескольких узлах. Основной экземпляр Redis (также называемый ведущим) записывает все изменения данных в журнал репликации, а вторичные экземпляры (также называемые подчиненными) читают и применяют эти изменения. Это обеспечивает масштабируемость чтения и повышенную отказоустойчивость, поскольку ведомые устройства могут быть повышены до уровня ведущего в случае сбоя основного узла. Репликация — полезный метод масштабирования рабочих нагрузок с большим количеством операций чтения, но он не увеличивает емкость записи.

Шардинг в Redis включает в себя разделение набора данных на несколько экземпляров или сегментов Redis, при этом каждый сегмент отвечает за подмножество данных. Это обеспечивает масштабируемость как для чтения, так и для записи, поскольку каждый сегмент может обрабатывать часть трафика. Разделение также обеспечивает отказоустойчивость, поскольку сбой одного сегмента не приводит к выходу из строя всей системы. Однако сегментирование может быть более сложным для реализации и может привести к увеличению задержки в сети из-за распространения данных по нескольким узлам.

Таким образом, репликация в Redis — это способ создания нескольких копий одного и того же экземпляра Redis, доступных только для чтения, для повышения отказоустойчивости и масштабируемости чтения, а сегментирование — это способ разделения набора данных между несколькими экземплярами Redis для улучшения масштабируемости чтения и записи.

## Как обновить сайт с высокой посещаемостью с минимальным или нулевым временем простоя?
Обновление сайта с высоким трафиком может быть сложной задачей, но есть несколько стратегий, которые можно использовать для минимизации или устранения простоев:

1.  Используйте балансировщик нагрузки: балансировщик нагрузки может распределять трафик между несколькими серверами, позволяя вам обновлять один сервер за раз, в то время как другие продолжают обслуживать трафик. Это может помочь свести к минимуму время простоя и поддерживать доступность услуг.
    
2.  Используйте сине-зеленую стратегию развертывания. При сине-зеленой стратегии развертывания вы развертываете новую версию своего приложения вместе с существующей версией и переключаете трафик на новую версию, как только она будет готова. Такой подход позволяет убедиться, что новая версия работает правильно, прежде чем направлять на нее трафик, и это можно сделать с минимальным временем простоя или вообще без него.
    
3.  Используйте стратегию скользящего развертывания: скользящее развертывание включает в себя обновление одного сервера за раз, что позволяет постепенно перенаправлять трафик на обновленные серверы по мере их доступности. Этот подход может помочь свести к минимуму время простоя, гарантируя, что некоторые серверы всегда доступны для обслуживания трафика.
    
4.  Используйте кэширование и сети доставки контента (CDN). Кэширование и CDN могут помочь снизить нагрузку на ваши серверы и повысить производительность, упрощая обновление серверов без простоев. Кэшируя часто запрашиваемый контент и предоставляя его из CDN, вы можете уменьшить количество запросов, которые должны обрабатываться вашими серверами.
    
5.  Планируйте заранее. Наконец, важно заранее планировать и тщательно тестировать обновления перед их развертыванием в рабочей среде. Это может помочь вам заранее определить потенциальные проблемы и свести к минимуму риск простоя в процессе обновления.

## Как можно протестировать приватную функцию или класс, у которого есть приватные методы, поля или вложенные классы?
Закрытые методы, поля и вложенные классы намеренно скрыты от внешнего доступа и не предназначены для непосредственного тестирования. Однако в NodeJS все еще есть способы протестировать частные функции или классы.

Один из подходов заключается в использовании тестовой библиотеки, которая предоставляет возможность доступа к закрытым членам, таким как библиотеки `rewire`или `proxyquire`. Эти библиотеки позволяют заменить частные члены модуля тестовыми двойниками или макетами, которые затем можно использовать для тестирования общедоступного API модуля.

Другой подход заключается в использовании метода, называемого "тестирование белого ящика", когда вы модифицируете тестируемый код, чтобы предоставить доступ к закрытым членам для целей тестирования. Например, вы можете добавить временный общедоступный метод, который предоставляет закрытые члены во время тестирования, а затем удалить его после завершения тестов.

Кроме того, вы также можете косвенно протестировать частные члены, протестировав общедоступный API, который зависит от этих закрытых членов. Например, если частный метод вызывается общедоступным методом, вы можете протестировать общедоступный метод и косвенно проверить поведение закрытого метода.

Стоит отметить, что тестирование закрытых членов иногда может быть признаком архитектурной проблемы или нарушения принципа инкапсуляции. Если вам нужно часто тестировать закрытые члены, возможно, стоит подумать о рефакторинге вашего кода, чтобы улучшить его тестируемость и удобство сопровождения.

## Можете ли вы предложить, как балансировать нагрузку Web Sockets?
WebSockets — популярный выбор для приложений реального времени, требующий особого внимания для балансировки нагрузки. Вот несколько стратегий балансировки нагрузки WebSockets:

1.  Используйте выделенный балансировщик нагрузки: выделенные балансировщики нагрузки для WebSockets разработаны с учетом уникальных требований WebSockets. Они могут поддерживать постоянные соединения и маршрутизировать трафик на основе протокола WebSocket. Некоторые примеры выделенных балансировщиков нагрузки WebSocket включают HAProxy и NGINX.
    
2.  Маршрутизируйте трафик WebSocket на основе сходства сеансов. Чтобы поддерживать состояние соединения WebSocket, важно направлять трафик от одного клиента к одному и тому же серверу. Сходство сеансов, также известное как закрепленные сеансы, — это метод, обеспечивающий направление всего трафика от определенного клиента на один и тот же сервер. Этого можно добиться с помощью балансировщика нагрузки, который поддерживает сходство сеансов.
    
3.  Реализуйте пул соединений WebSocket: WebSockets может потреблять значительные ресурсы сервера, поэтому важно ограничить количество открытых соединений. Пул соединений может помочь сократить количество соединений и оптимизировать использование ресурсов. При таком подходе сервер поддерживает пул предварительно установленных соединений WebSocket, которые можно повторно использовать для входящих соединений.
    
4.  Используйте распределенный кеш. Распределенный кеш, такой как Redis или Memcached, может помочь повысить производительность и снизить нагрузку на сервер за счет кэширования данных в памяти. Это может быть особенно полезно для хранения и извлечения данных сеанса, связанных с соединениями WebSocket.
    
5.  Внедрение бессерверных веб-сокетов. Бессерверные архитектуры, такие как AWS Lambda или Azure Functions, можно использовать для обработки трафика веб-сокетов без необходимости в выделенном сервере. В бессерверной настройке WebSocket состояние подключения может храниться в базе данных или кэше, а бессерверная функция используется для обработки входящих сообщений и обновления состояния.

## Чем отличаются функции spawn и execute в модуле child_process в Node.js? Когда использовать каждую из них?
Модуль `child_process` в Node.js предоставляет две функции для создания дочерних процессов: `spawn()` и `exec()` (не `execute`). Вот разница между ними:

1.  `spawn()`: `spawn()` функция запускает новый процесс с заданной командой, аргументами и параметрами. Он возвращает `ChildProcess` объект, который можно использовать для взаимодействия с порожденным процессом. Порожденный процесс запускается асинхронно, а его вывод обрабатывается с помощью потоков. Это означает, что `spawn()` это неблокирующая функция, которую можно использовать для длительных процессов или когда вам нужно передавать данные между родительским и дочерним процессами.
    
2.  `exec()`: `exec()` Функция выполняет команду в оболочке и буферизует вывод. Он возвращает буферизованный вывод после завершения команды. В отличие от `spawn()`, `exec()` является блокирующей функцией и лучше всего подходит для кратковременных процессов или когда вам нужно получить полный вывод команды.

В общем, вы должны использовать `spawn()`, когда вам нужно запустить длительный процесс или когда вам нужно передать данные между родительским и дочерним процессами. Вы должны использовать `exec()`, когда вам нужно выполнить недолговечный процесс и хотите зафиксировать его выходные данные.

Вот пример использования `spawn()` для запуска дочернего процесса и потоковой передачи его вывода родительскому процессу:

```javascript
const { spawn } = require('child_process');

const child = spawn('ls', ['-l']);

child.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

child.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

child.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

А вот пример использования `exec()` для выполнения команды и захвата ее вывода:

```javascript
const { exec } = require('child_process');

exec('ls -l', (err, stdout, stderr) => {
  if (err) {
    console.error(`exec error: ${err}`);
    return;
  }

  console.log(`stdout: ${stdout}`);
  console.error(`stderr: ${stderr}`);
});
```

## Как можно использовать общий код между файлами?
В Node.js вы можете использовать общий код между файлами, экспортируя и импортируя модули.

Вот пример того, как экспортировать модуль в файл с именем `myModule.js`:

```javascript
// myModule.js

const myModule = {
  foo: 'bar',
  baz: () => console.log('qux')
};

module.exports = myModule;
```

В этом примере мы экспортируем объект `myModule` с двумя свойствами: `foo`и `baz`. Мы используем это `module.exports` свойство для экспорта модуля.

Чтобы импортировать этот модуль в другой файл, вы можете использовать `require()`функцию:

```javascript
// app.js

const myModule = require('./myModule');

console.log(myModule.foo); // 'bar'
myModule.baz(); // 'qux'
```

В этом примере мы импортируем `myModule`модуль из `myModule.js`файла с помощью `require()`функции. Затем мы используем свойства импортированного модуля в нашем приложении.

Вы также можете использовать именованные экспорты вместо экспортов по умолчанию:

```javascript
// myModule.js

const foo = 'bar';
const baz = () => console.log('qux');

module.exports = {
  foo,
  baz
};
```

Чтобы импортировать именованные экспорты, вы можете использовать назначение деструктурирования:

```javascript
// app.js

const { foo, baz } = require('./myModule');

console.log(foo); // 'bar'
baz(); // 'qux'
```

В этом примере мы используем назначение деструктурирования для импорта свойств `foo`и `baz`из `myModule`модуля. Затем мы можем использовать эти свойства в нашем приложении.
## Каковы ключевые особенности Node.js?
Node.js — это популярная серверная среда выполнения с открытым исходным кодом, которая позволяет разработчикам создавать быстрые, масштабируемые и высокоэффективные приложения. Некоторые из ключевых особенностей Node.js включают в себя:

1.  Модель асинхронного и управляемого событиями программирования: Node.js спроектирован так, чтобы быть асинхронным и управляемым событиями, что делает его очень эффективным для обработки операций ввода-вывода. Он использует цикл обработки событий для обработки операций ввода-вывода, что позволяет обрабатывать большое количество одновременных подключений без блокировки.
    
2.  Серверный JavaScript: Node.js позволяет разработчикам использовать JavaScript на стороне сервера, что упрощает создание как клиентских, так и серверных приложений с использованием одного и того же языка.
    
3.  Неблокирующий ввод-вывод: Node.js построен на неблокирующей модели ввода-вывода, что означает, что он может обрабатывать множество одновременных запросов, не дожидаясь завершения предыдущих запросов.
    
4.  NPM: Node.js поставляется с менеджером пакетов под названием NPM, который обеспечивает доступ к огромному количеству пакетов и библиотек с открытым исходным кодом, которые можно легко установить и использовать в приложениях Node.js.
    
5.  Однопоточный цикл обработки событий: Node.js построен на основе однопоточной архитектуры цикла обработки событий, что обеспечивает высокую масштабируемость и эффективность.
    
6.  Межплатформенная поддержка: Node.js работает на нескольких платформах, включая Windows, Linux и macOS.
    
7.  Архитектура микросервисов: Node.js хорошо подходит для создания архитектур на основе микросервисов благодаря своей небольшой площади и способности обрабатывать множество одновременных подключений.
    
8.  Богатая экосистема: Node.js имеет большое и активное сообщество разработчиков, что привело к созданию богатой экосистемы модулей и инструментов, которые можно использовать для быстрого и эффективного создания сложных приложений.

В целом Node.js предоставляет разработчикам мощный набор инструментов для создания быстрых, масштабируемых и высокоэффективных серверных приложений.
 
## Для чего нужен Sec-WebSocket-Key?
Sec-WebSocket-Key — это заголовок, который используется в процессе рукопожатия протокола WebSocket. Когда клиент хочет установить соединение WebSocket с сервером, он отправляет HTTP-запрос на обновление с заголовком Sec-WebSocket-Key.

Значение заголовка Sec-WebSocket-Key представляет собой строку в кодировке base64, которая используется для вычисления ответа, чтобы доказать, что клиент является законным. Затем сервер отвечает HTTP-ответом на обновление, который включает заголовок Sec-WebSocket-Accept, который содержит хэш SHA-1 конкатенации значения Sec-WebSocket-Key клиента и предопределенной строки, объединенной с хэшем SHA-1. заранее определенного значения.

Вычисляя этот хэш, сервер может убедиться, что клиент является законным и что соединение WebSocket может быть установлено. Это помогает предотвратить мошеннические подключения и гарантирует, что сервер взаимодействует только с законными клиентами.

Таким образом, заголовок Sec-WebSocket-Key используется в процессе рукопожатия протокола WebSocket для установления безопасного и надежного соединения между клиентом и сервером.

## В чем разница между Unit-тестами и интеграционными тестами?
Модульные тесты и интеграционные тесты — это два типа тестирования программного обеспечения, которые служат разным целям.

Модульные тесты — это тесты, предназначенные для изолированного тестирования отдельных модулей или компонентов кода. Эти тесты обычно автоматизированы, выполняются быстро и используются для проверки правильности работы отдельных блоков кода. Модульные тесты обычно пишутся разработчиками и часто являются частью процесса непрерывной интеграции или непрерывной доставки.

Интеграционные тесты, с другой стороны, — это тесты, предназначенные для проверки того, как различные блоки кода работают вместе как система. Эти тесты обычно выполняются вручную или с помощью инструментов автоматизированного тестирования и используются для проверки правильности совместной работы различных компонентов системы. Интеграционные тесты часто выполняются группами контроля качества или специализированными группами тестирования и обычно выполняются реже, чем модульные тесты.

Вот некоторые ключевые различия между модульными тестами и интеграционными тестами:

1.  Область применения: Модульные тесты сосредоточены на тестировании отдельных модулей или компонентов кода, а интеграционные тесты — на проверке того, как различные блоки кода работают вместе как система.
    
2.  Скорость: модульные тесты обычно автоматизированы и выполняются быстро, в то время как интеграционные тесты часто выполняются вручную или с помощью инструментов автоматизированного тестирования, и их выполнение может занять больше времени.
    
3.  Изоляция. Модульные тесты предназначены для изолированного тестирования отдельных блоков кода, а интеграционные тесты проверяют, как разные блоки кода работают вместе, и могут потребовать более сложной настройки.
    
4.  Зависимость: модульные тесты не зависят от внешних систем или ресурсов, в то время как интеграционные тесты могут зависеть от внешних систем или ресурсов, таких как базы данных, веб-службы или сетевые подключения.

Таким образом, модульные тесты используются для проверки правильности функционирования отдельных блоков кода, а интеграционные тесты используются для проверки правильности совместной работы различных компонентов системы. Оба типа тестирования важны для обеспечения качества и надежности программного обеспечения.

## Что такое Структурная Типизация?

## Как Node.js обрабатывает дочерние потоки?

## Вы знакомы с различиями между модулями Node.js и модулями ES6?

## Какие еще существуют типы индексов (в отличие от B-деревьев)?

## Какова фундаментальная ценность Unit-тестов по сравнению с интеграционными тестами?

## Укажите особенности Интерфейса

## В чем разница между WebSockets и Server-Sent Events/EventSource?

## Что бы вы изменили в TypeScript, если бы могли изменить только одну вещь?

## Назовите некоторые недостатки хэш-индекса.

## Когда следует использовать интерфейсы, а когда классы в TypeScript?

## Когда следует использовать EventEmitter?

## Объясните, что такое паттерн Reactor в Node.js?

## Почему оператор this в JavaScript несогласованный?

## Что такое Домен в DDD?

## Что такое Связность в ООП?

## Основан ли Node.js полностью на одном потоке?

## Что означает программировать по интерфейсу?

## Что такое оператор typeof в JavaScript?

## Что такое Sharding?

## Что такое Event Loop?

## Что означает Short-Circuiting в TypeScript?

## Почему для "нижних" уровней приложения хорошо, чтобы они не были осведомлены о "высших"?

## Что такое балансировка нагрузки с помощью "Sticky Session"? Что означает "Session Affinity"?

## Что такое Оптимистическая блокировка?

## В чем разница между cluster.fork() и child_process.fork() в Node.js?

## Какова цель оператора слияния нулей?

## Что такое V8?

## В чем разница между ES6 Map и WeakMap?

## Определите Temp Table

## Какова связь между классом и объектом?

## Когда следует использовать генераторы в ES6?

## Почему написание программного обеспечения является трудным? Что делает поддержку программного обеспечения сложной?

## Расскажите мне о разнице между HEAD, рабочим деревом и индексом в Git?

## Что такое export default в JavaScript?

## Как индекс базы данных может помочь улучшить производительность?

## Почему использовать WebSocket вместо HTTP?

## В чем разница между INNER JOIN, OUTER JOIN, FULL OUTER JOIN?

## Объясните проектные ссылки и их преимущества.

## Можно ли унаследовать приватные члены класса?

## В чем разница между событием загрузки документа и событием DOMContentLoaded документа?

## Что такое свойство ACID системы?

## Поддерживает ли Node.js многоядерные платформы? И способен ли он использовать все ядра?

## В чем разница между Абстрактной функцией и Виртуальной функцией?

## Что такое обратный вызов (Callback)?

## Что такое Git fork? В чем разница между fork, branch и clone?

## Как можно сохранить одну копию своего утилитарного кода и позволить нескольким компонентам-потребителям использовать и развертывать его?

## Что означает выражение "Fail Early", и когда следует так делать?

## Что такое балансировка нагрузки?

## Почему использовать Buffer вместо двоичной строки для работы с двоичными данными?

## Каковы преимущества возможностей импорта в TypeScript?

## Как использовать несколько CPU/ядер для Redis?

## Объясните понятие "Потоки" своим бабушкам и дедушкам.

## Чем отличается pm2 restart от pm2 reload?

## Объясните политику same-origin («одинаковый источник») в JavaScript.

## В чем разница между ключевым словом private и закрытыми полями (private fields) в TypeScript?

## Когда использовать Redis вместо MongoDB?

## Может ли Node.js использовать другие движки, кроме V8?

## Назовите некоторые преимущества Unit-тестирования для разработчиков, которые вы лично испытали

## Что такое кардинальность индекса и почему это важно?

## Является ли Redis устойчивым хранилищем данных («D» из ACID)?

## Можно ли запустить внешний процесс с помощью Node.js?

## В чем разница между классами и интерфейсами в TypeScript?

## Что такое масштабируемость?

## Что означает взаимодействие с более низкой задержкой?

## Когда следует использовать git stash?

## Стоит ли тратить усилия на Unit-тестирование?

## Какова стоимость использования индекса базы данных?

## В чем разница между setTimeout(fn, 0) и setImmediate(fn)?

## Что такое Type Erasure в TypeScript?

## Объясните, что такое паттерн Arrange-Act-Assert?

## Что такое stream и какие типы потоков доступны в Node.js?

## Объясните концепцию Конструктора

## Как индекс базы данных может повысить производительность?

## Что такое область видимости (Scope) в JavaScript?

## Перечислите встроенные типы в TypeScript.

## Можно ли использовать TypeScript на бэкэнде и как это сделать?

## Как написать unit-тест для объекта с запросами в базу данных?

## Каковы преимущества использования синтаксиса spread в ES6 и в чем он отличается от синтаксиса rest?

## Назовите некоторые Встроенные глобальные объекты в Node.js.

## Когда бы вы использовали import * as X из 'X'?

## Что такое тип объекта (object type) в JavaScript?

## В чем разница между переменной, которая равна: null, undefined или необъявленная? Как бы вы проверили любое из этих состояний?

## Зачем мы используем ключевое слово abstract для классов и их методов в TypeScript?

## Что значит аббревиатура SOLID и каковы ее принципы?

## Что означает техника промисификации (Promisifying) в Node.js?

## Как создать тип-объединение из свойств псевдонима типа или интерфейса в TypeScript?

## Как решить исключение Process out of Memory в Node.js?

## Каковы преимущества использования Node.js?

## Когда использовать тип данных списков в Redis?

## Опишите, что такое шаблон Event Sourcing.


