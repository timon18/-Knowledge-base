17-04-2023
08:59
Authors: 
***
Tags: #nodeJS
***
# Ячейки 2-101

## Когда следует использовать базу данных NoSQL вместо реляционной базы данных?
Вам следует рассмотреть возможность использования базы данных NoSQL вместо реляционной базы данных, когда:

1.  У вас есть большие объемы неструктурированных или полуструктурированных данных: базы данных NoSQL предназначены для обработки больших объемов неструктурированных или полуструктурированных данных, что делает их идеальными для таких случаев использования, как социальные сети, Интернет вещей и анализ данных в реальном времени.
    
2.  Вам нужна горизонтальная масштабируемость: базы данных NoSQL можно легко масштабировать горизонтально, добавляя дополнительные серверы, что сложно сделать с традиционными реляционными базами данных. Это делает базы данных NoSQL хорошо подходящими для приложений с высокими требованиями к масштабируемости.
    
3.  У вас есть гибкая схема данных: в отличие от реляционных баз данных, базы данных NoSQL не имеют строгой схемы, поэтому вы можете легко добавлять новые поля или изменять существующие, не требуя миграции. Это облегчает адаптацию к изменяющимся требованиям и обработку данных, которые постоянно развиваются.
    
4.  Вам нужна высокая доступность и отказоустойчивость: базы данных NoSQL спроектированы так, чтобы быть высокодоступными и отказоустойчивыми, что делает их хорошим выбором для приложений, которым требуется постоянное время безотказной работы и минимальное время простоя.

При этом важно отметить, что базы данных NoSQL не являются панацеей, и при их использовании есть компромиссы. Например, базы данных NoSQL могут не так подходить для сложных транзакций и запросов, как реляционные базы данных. В конечном итоге выбор между NoSQL и реляционной базой данных зависит от ваших конкретных требований и варианта использования.

## В чем разница между репликацией и шардингом в Redis?
Репликация и сегментирование — это два разных способа горизонтального масштабирования Redis для обработки больших наборов данных и более высоких нагрузок трафика.

Репликация в Redis включает создание копий одного и того же экземпляра Redis на нескольких узлах. Основной экземпляр Redis (также называемый ведущим) записывает все изменения данных в журнал репликации, а вторичные экземпляры (также называемые подчиненными) читают и применяют эти изменения. Это обеспечивает масштабируемость чтения и повышенную отказоустойчивость, поскольку ведомые устройства могут быть повышены до уровня ведущего в случае сбоя основного узла. Репликация — полезный метод масштабирования рабочих нагрузок с большим количеством операций чтения, но он не увеличивает емкость записи.

Шардинг в Redis включает в себя разделение набора данных на несколько экземпляров или сегментов Redis, при этом каждый сегмент отвечает за подмножество данных. Это обеспечивает масштабируемость как для чтения, так и для записи, поскольку каждый сегмент может обрабатывать часть трафика. Разделение также обеспечивает отказоустойчивость, поскольку сбой одного сегмента не приводит к выходу из строя всей системы. Однако сегментирование может быть более сложным для реализации и может привести к увеличению задержки в сети из-за распространения данных по нескольким узлам.

Таким образом, репликация в Redis — это способ создания нескольких копий одного и того же экземпляра Redis, доступных только для чтения, для повышения отказоустойчивости и масштабируемости чтения, а сегментирование — это способ разделения набора данных между несколькими экземплярами Redis для улучшения масштабируемости чтения и записи.

## Как обновить сайт с высокой посещаемостью с минимальным или нулевым временем простоя?
Обновление сайта с высоким трафиком может быть сложной задачей, но есть несколько стратегий, которые можно использовать для минимизации или устранения простоев:

1.  Используйте балансировщик нагрузки: балансировщик нагрузки может распределять трафик между несколькими серверами, позволяя вам обновлять один сервер за раз, в то время как другие продолжают обслуживать трафик. Это может помочь свести к минимуму время простоя и поддерживать доступность услуг.
    
2.  Используйте сине-зеленую стратегию развертывания. При сине-зеленой стратегии развертывания вы развертываете новую версию своего приложения вместе с существующей версией и переключаете трафик на новую версию, как только она будет готова. Такой подход позволяет убедиться, что новая версия работает правильно, прежде чем направлять на нее трафик, и это можно сделать с минимальным временем простоя или вообще без него.
    
3.  Используйте стратегию скользящего развертывания: скользящее развертывание включает в себя обновление одного сервера за раз, что позволяет постепенно перенаправлять трафик на обновленные серверы по мере их доступности. Этот подход может помочь свести к минимуму время простоя, гарантируя, что некоторые серверы всегда доступны для обслуживания трафика.
    
4.  Используйте кэширование и сети доставки контента (CDN). Кэширование и CDN могут помочь снизить нагрузку на ваши серверы и повысить производительность, упрощая обновление серверов без простоев. Кэшируя часто запрашиваемый контент и предоставляя его из CDN, вы можете уменьшить количество запросов, которые должны обрабатываться вашими серверами.
    
5.  Планируйте заранее. Наконец, важно заранее планировать и тщательно тестировать обновления перед их развертыванием в рабочей среде. Это может помочь вам заранее определить потенциальные проблемы и свести к минимуму риск простоя в процессе обновления.

## Как можно протестировать приватную функцию или класс, у которого есть приватные методы, поля или вложенные классы?
Закрытые методы, поля и вложенные классы намеренно скрыты от внешнего доступа и не предназначены для непосредственного тестирования. Однако в NodeJS все еще есть способы протестировать частные функции или классы.

Один из подходов заключается в использовании тестовой библиотеки, которая предоставляет возможность доступа к закрытым членам, таким как библиотеки `rewire`или `proxyquire`. Эти библиотеки позволяют заменить частные члены модуля тестовыми двойниками или макетами, которые затем можно использовать для тестирования общедоступного API модуля.

Другой подход заключается в использовании метода, называемого "тестирование белого ящика", когда вы модифицируете тестируемый код, чтобы предоставить доступ к закрытым членам для целей тестирования. Например, вы можете добавить временный общедоступный метод, который предоставляет закрытые члены во время тестирования, а затем удалить его после завершения тестов.

Кроме того, вы также можете косвенно протестировать частные члены, протестировав общедоступный API, который зависит от этих закрытых членов. Например, если частный метод вызывается общедоступным методом, вы можете протестировать общедоступный метод и косвенно проверить поведение закрытого метода.

Стоит отметить, что тестирование закрытых членов иногда может быть признаком архитектурной проблемы или нарушения принципа инкапсуляции. Если вам нужно часто тестировать закрытые члены, возможно, стоит подумать о рефакторинге вашего кода, чтобы улучшить его тестируемость и удобство сопровождения.

## Можете ли вы предложить, как балансировать нагрузку Web Sockets?
WebSockets — популярный выбор для приложений реального времени, требующий особого внимания для балансировки нагрузки. Вот несколько стратегий балансировки нагрузки WebSockets:

1.  Используйте выделенный балансировщик нагрузки: выделенные балансировщики нагрузки для WebSockets разработаны с учетом уникальных требований WebSockets. Они могут поддерживать постоянные соединения и маршрутизировать трафик на основе протокола WebSocket. Некоторые примеры выделенных балансировщиков нагрузки WebSocket включают HAProxy и NGINX.
    
2.  Маршрутизируйте трафик WebSocket на основе сходства сеансов. Чтобы поддерживать состояние соединения WebSocket, важно направлять трафик от одного клиента к одному и тому же серверу. Сходство сеансов, также известное как закрепленные сеансы, — это метод, обеспечивающий направление всего трафика от определенного клиента на один и тот же сервер. Этого можно добиться с помощью балансировщика нагрузки, который поддерживает сходство сеансов.
    
3.  Реализуйте пул соединений WebSocket: WebSockets может потреблять значительные ресурсы сервера, поэтому важно ограничить количество открытых соединений. Пул соединений может помочь сократить количество соединений и оптимизировать использование ресурсов. При таком подходе сервер поддерживает пул предварительно установленных соединений WebSocket, которые можно повторно использовать для входящих соединений.
    
4.  Используйте распределенный кеш. Распределенный кеш, такой как Redis или Memcached, может помочь повысить производительность и снизить нагрузку на сервер за счет кэширования данных в памяти. Это может быть особенно полезно для хранения и извлечения данных сеанса, связанных с соединениями WebSocket.
    
5.  Внедрение бессерверных веб-сокетов. Бессерверные архитектуры, такие как AWS Lambda или Azure Functions, можно использовать для обработки трафика веб-сокетов без необходимости в выделенном сервере. В бессерверной настройке WebSocket состояние подключения может храниться в базе данных или кэше, а бессерверная функция используется для обработки входящих сообщений и обновления состояния.

## Чем отличаются функции spawn и execute в модуле child_process в Node.js? Когда использовать каждую из них?
Модуль `child_process` в Node.js предоставляет две функции для создания дочерних процессов: `spawn()` и `exec()` (не `execute`). Вот разница между ними:

1.  `spawn()`: `spawn()` функция запускает новый процесс с заданной командой, аргументами и параметрами. Он возвращает `ChildProcess` объект, который можно использовать для взаимодействия с порожденным процессом. Порожденный процесс запускается асинхронно, а его вывод обрабатывается с помощью потоков. Это означает, что `spawn()` это неблокирующая функция, которую можно использовать для длительных процессов или когда вам нужно передавать данные между родительским и дочерним процессами.
    
2.  `exec()`: `exec()` Функция выполняет команду в оболочке и буферизует вывод. Он возвращает буферизованный вывод после завершения команды. В отличие от `spawn()`, `exec()` является блокирующей функцией и лучше всего подходит для кратковременных процессов или когда вам нужно получить полный вывод команды.

В общем, вы должны использовать `spawn()`, когда вам нужно запустить длительный процесс или когда вам нужно передать данные между родительским и дочерним процессами. Вы должны использовать `exec()`, когда вам нужно выполнить недолговечный процесс и хотите зафиксировать его выходные данные.

Вот пример использования `spawn()` для запуска дочернего процесса и потоковой передачи его вывода родительскому процессу:

```javascript
const { spawn } = require('child_process');

const child = spawn('ls', ['-l']);

child.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

child.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

child.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

А вот пример использования `exec()` для выполнения команды и захвата ее вывода:

```javascript
const { exec } = require('child_process');

exec('ls -l', (err, stdout, stderr) => {
  if (err) {
    console.error(`exec error: ${err}`);
    return;
  }

  console.log(`stdout: ${stdout}`);
  console.error(`stderr: ${stderr}`);
});
```

## Как можно использовать общий код между файлами?
В Node.js вы можете использовать общий код между файлами, экспортируя и импортируя модули.

Вот пример того, как экспортировать модуль в файл с именем `myModule.js`:

```javascript
// myModule.js

const myModule = {
  foo: 'bar',
  baz: () => console.log('qux')
};

module.exports = myModule;
```

В этом примере мы экспортируем объект `myModule` с двумя свойствами: `foo`и `baz`. Мы используем это `module.exports` свойство для экспорта модуля.

Чтобы импортировать этот модуль в другой файл, вы можете использовать `require()`функцию:

```javascript
// app.js

const myModule = require('./myModule');

console.log(myModule.foo); // 'bar'
myModule.baz(); // 'qux'
```

В этом примере мы импортируем `myModule`модуль из `myModule.js`файла с помощью `require()`функции. Затем мы используем свойства импортированного модуля в нашем приложении.

Вы также можете использовать именованные экспорты вместо экспортов по умолчанию:

```javascript
// myModule.js

const foo = 'bar';
const baz = () => console.log('qux');

module.exports = {
  foo,
  baz
};
```

Чтобы импортировать именованные экспорты, вы можете использовать назначение деструктурирования:

```javascript
// app.js

const { foo, baz } = require('./myModule');

console.log(foo); // 'bar'
baz(); // 'qux'
```

В этом примере мы используем назначение деструктурирования для импорта свойств `foo`и `baz`из `myModule`модуля. Затем мы можем использовать эти свойства в нашем приложении.
## Каковы ключевые особенности Node.js?
Node.js — это популярная серверная среда выполнения с открытым исходным кодом, которая позволяет разработчикам создавать быстрые, масштабируемые и высокоэффективные приложения. Некоторые из ключевых особенностей Node.js включают в себя:

1.  Модель асинхронного и управляемого событиями программирования: Node.js спроектирован так, чтобы быть асинхронным и управляемым событиями, что делает его очень эффективным для обработки операций ввода-вывода. Он использует цикл обработки событий для обработки операций ввода-вывода, что позволяет обрабатывать большое количество одновременных подключений без блокировки.
    
2.  Серверный JavaScript: Node.js позволяет разработчикам использовать JavaScript на стороне сервера, что упрощает создание как клиентских, так и серверных приложений с использованием одного и того же языка.
    
3.  Неблокирующий ввод-вывод: Node.js построен на неблокирующей модели ввода-вывода, что означает, что он может обрабатывать множество одновременных запросов, не дожидаясь завершения предыдущих запросов.
    
4.  NPM: Node.js поставляется с менеджером пакетов под названием NPM, который обеспечивает доступ к огромному количеству пакетов и библиотек с открытым исходным кодом, которые можно легко установить и использовать в приложениях Node.js.
    
5.  Однопоточный цикл обработки событий: Node.js построен на основе однопоточной архитектуры цикла обработки событий, что обеспечивает высокую масштабируемость и эффективность.
    
6.  Межплатформенная поддержка: Node.js работает на нескольких платформах, включая Windows, Linux и macOS.
    
7.  Архитектура микросервисов: Node.js хорошо подходит для создания архитектур на основе микросервисов благодаря своей небольшой площади и способности обрабатывать множество одновременных подключений.
    
8.  Богатая экосистема: Node.js имеет большое и активное сообщество разработчиков, что привело к созданию богатой экосистемы модулей и инструментов, которые можно использовать для быстрого и эффективного создания сложных приложений.

В целом Node.js предоставляет разработчикам мощный набор инструментов для создания быстрых, масштабируемых и высокоэффективных серверных приложений.
 
## Для чего нужен Sec-WebSocket-Key?
Sec-WebSocket-Key — это заголовок, который используется в процессе рукопожатия протокола WebSocket. Когда клиент хочет установить соединение WebSocket с сервером, он отправляет HTTP-запрос на обновление с заголовком Sec-WebSocket-Key.

Значение заголовка Sec-WebSocket-Key представляет собой строку в кодировке base64, которая используется для вычисления ответа, чтобы доказать, что клиент является законным. Затем сервер отвечает HTTP-ответом на обновление, который включает заголовок Sec-WebSocket-Accept, который содержит хэш SHA-1 конкатенации значения Sec-WebSocket-Key клиента и предопределенной строки, объединенной с хэшем SHA-1. заранее определенного значения.

Вычисляя этот хэш, сервер может убедиться, что клиент является законным и что соединение WebSocket может быть установлено. Это помогает предотвратить мошеннические подключения и гарантирует, что сервер взаимодействует только с законными клиентами.

Таким образом, заголовок Sec-WebSocket-Key используется в процессе рукопожатия протокола WebSocket для установления безопасного и надежного соединения между клиентом и сервером.

## В чем разница между Unit-тестами и интеграционными тестами?
Модульные тесты и интеграционные тесты — это два типа тестирования программного обеспечения, которые служат разным целям.

Модульные тесты — это тесты, предназначенные для изолированного тестирования отдельных модулей или компонентов кода. Эти тесты обычно автоматизированы, выполняются быстро и используются для проверки правильности работы отдельных блоков кода. Модульные тесты обычно пишутся разработчиками и часто являются частью процесса непрерывной интеграции или непрерывной доставки.

Интеграционные тесты, с другой стороны, — это тесты, предназначенные для проверки того, как различные блоки кода работают вместе как система. Эти тесты обычно выполняются вручную или с помощью инструментов автоматизированного тестирования и используются для проверки правильности совместной работы различных компонентов системы. Интеграционные тесты часто выполняются группами контроля качества или специализированными группами тестирования и обычно выполняются реже, чем модульные тесты.

Вот некоторые ключевые различия между модульными тестами и интеграционными тестами:

1.  Область применения: Модульные тесты сосредоточены на тестировании отдельных модулей или компонентов кода, а интеграционные тесты — на проверке того, как различные блоки кода работают вместе как система.
    
2.  Скорость: модульные тесты обычно автоматизированы и выполняются быстро, в то время как интеграционные тесты часто выполняются вручную или с помощью инструментов автоматизированного тестирования, и их выполнение может занять больше времени.
    
3.  Изоляция. Модульные тесты предназначены для изолированного тестирования отдельных блоков кода, а интеграционные тесты проверяют, как разные блоки кода работают вместе, и могут потребовать более сложной настройки.
    
4.  Зависимость: модульные тесты не зависят от внешних систем или ресурсов, в то время как интеграционные тесты могут зависеть от внешних систем или ресурсов, таких как базы данных, веб-службы или сетевые подключения.

Таким образом, модульные тесты используются для проверки правильности функционирования отдельных блоков кода, а интеграционные тесты используются для проверки правильности совместной работы различных компонентов системы. Оба типа тестирования важны для обеспечения качества и надежности программного обеспечения.

## Что такое Структурная Типизация?
Структурная типизация, также известная как утиная типизация, представляет собой систему типов в языках программирования, которая определяет совместимость типов объектов на основе их структуры или формы, а не явных объявлений типов. Другими словами, два объекта считаются принадлежащими к одному типу, если они имеют одинаковую структуру или форму, независимо от того, имеют ли они один и тот же явный тип.

Структурная типизация, также известная как утиная типизация, — это функция JavaScript, которая позволяет классифицировать объекты на основе их структуры или формы, а не явных объявлений типов. Это означает, что два объекта считаются объектами одного типа, если они имеют одинаковую структуру или форму, даже если они имеют разные явные типы.

В JavaScript структурная типизация используется для определения совместимости объектов на основе их свойств и методов. Например, если два объекта имеют одинаковый набор свойств и методов, они считаются принадлежащими к одному типу, даже если они были созданы независимо и имеют разные явные типы.

Одно из ключевых преимуществ структурной типизации в JavaScript заключается в том, что она позволяет создавать более гибкий и динамичный код, поскольку объекты можно использовать взаимозаменяемо, если они имеют одинаковую структуру или форму. Это может упростить процесс разработки и привести к созданию более лаконичного и удобного в сопровождении кода.

Однако одним потенциальным недостатком структурной типизации является то, что она может затруднить понимание кода, поскольку тип объекта может быть не сразу очевиден из его явного объявления типа. Кроме того, структурная типизация может привести к ошибкам во время выполнения, если объекты используются непредвиденным образом, поскольку тип объекта не всегда проверяется во время компиляции.

В целом, структурная типизация — важная функция JavaScript, позволяющая создавать более гибкий и динамичный код, но ее следует использовать с осторожностью, чтобы гарантировать безопасное и последовательное использование объектов.

## Как Node.js обрабатывает дочерние потоки?
В Node.js вы можете обрабатывать дочерние потоки с помощью `child_process`модуля, который позволяет создавать дочерние процессы и управлять ими.

Чтобы создать дочерний процесс, вы можете использовать `spawn`метод, который запускает новый процесс и возвращает `ChildProcess`объект, который вы можете использовать для связи с дочерним процессом. Метод `spawn`принимает команду в качестве первого аргумента, который представляет собой имя исполняемого файла или сценария, который вы хотите запустить, и массив аргументов в качестве второго аргумента, которые являются аргументами для передачи команде.

Например, чтобы создать дочерний процесс, который запускает скрипт Node.js, вы можете использовать следующий код:

```javascript
const { spawn } = require('child_process');

const child = spawn('node', ['child.js']);
```

Создав дочерний процесс, вы можете взаимодействовать с ним, используя стандартные потоки ввода, вывода и ошибок. Например, вы можете отправлять данные дочернему процессу, используя его `stdin`поток, и получать данные от дочернего процесса, используя его `stdout`и `stderr`потоки.

Для обработки нескольких дочерних процессов вы можете создать пул дочерних процессов с помощью модуля `cluster`, который позволяет распределить нагрузку между несколькими дочерними процессами. Модуль `cluster`использует `child_process`модуль для создания дочерних процессов и предоставляет простой API для управления дочерними процессами.

Чтобы использовать `cluster`модуль, вы можете создать главный процесс, который управляет пулом дочерних процессов, и использовать этот `fork`метод для создания новых дочерних процессов. Метод `fork`аналогичен методу `spawn`, но автоматически запускает новый дочерний процесс и общается с ним по специальному каналу IPC.

Например, для создания пула дочерних процессов с помощью `cluster`модуля можно использовать следующий код:
```javascript
const cluster = require('cluster');
const os = require('os');

if (cluster.isMaster) {
  const numWorkers = os.cpus().length;
  console.log(`Master process is running with ${numWorkers} workers`);

  for (let i = 0; i < numWorkers; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died with code ${code} and signal ${signal}`);
    console.log(`Starting a new worker`);
    cluster.fork();
  });
} else {
  console.log(`Worker process ${process.pid} is running`);
}
```

В этом примере главный процесс создает пул дочерних процессов, равный количеству доступных ядер ЦП, и отслеживает их сбои или выходы. Когда дочерний процесс завершается, главный процесс запускает новый дочерний процесс, чтобы заменить его.

В целом, обработка дочерних потоков в Node.js может выполняться с помощью `child_process`модуля или `cluster`модуля, в зависимости от вашего конкретного варианта использования и требований.
## Вы знакомы с различиями между модулями Node.js и модулями ES6?
Модули Node.js используют формат модулей CommonJS, предназначенный для работы с модульной системой Node.js. Модули Node.js загружаются с помощью `require`функции, которая принимает путь к модулю в качестве аргумента и возвращает экспорт модуля. Модули Node.js выполняются синхронно, а их экспорт кэшируется для повышения производительности.

Модули ES6, с другой стороны, используют формат модуля ES6, который предназначен для работы с современными веб-браузерами и другими средами JavaScript. Модули ES6 загружаются с использованием ключевых слов `import`и `export`, которые позволяют импортировать и экспортировать именованные значения или значения по умолчанию из модуля. Модули ES6 выполняются асинхронно, и их экспорт не кэшируется.

Вот некоторые ключевые различия между модулями Node.js и модулями ES6:

1.  Синтаксис: модули Node.js используют `require`функцию для загрузки модулей, а модули ES6 используют ключевые слова `import`и `export`.
    
2.  Расширения файлов: модули Node.js обычно сохраняются с `.js`расширением файла, тогда как модули ES6 обычно сохраняются с `.mjs`расширением файла.
    
3.  Область действия: Модули Node.js имеют локальную область действия, что означает, что их переменные и функции видны только внутри модуля. Модули ES6 имеют строгий режим, что означает, что их переменные и функции видны только внутри модуля, если только они не экспортированы явно.
    
4.  Кэширование: модули Node.js кэшируются для повышения производительности, а это означает, что последующие `require`вызовы будут возвращать кэшированный экспорт. Модули ES6 не кэшируются, что означает, что каждый `import`оператор будет выполнять модуль.
    
5.  Асинхронная загрузка: модули ES6 загружаются асинхронно, что означает, что их можно загружать параллельно и не блокировать основной поток. Модули Node.js загружаются синхронно, а это значит, что они загружаются по одному и могут блокировать основной поток.

В целом модули Node.js и модули ES6 имеют разный синтаксис, расширения файлов, области действия, механизмы кэширования и поведение при загрузке. Важно понимать эти различия при работе с обоими форматами модулей в вашем коде.

## Какие еще существуют типы индексов (в отличие от B-деревьев)?
В дополнение к B-деревьям существует несколько других типов индексов, в том числе:

1.  Хэш-индексы: хэш-индексы предназначены для быстрого поиска данных на основе хэш-значения. Они работают, хэшируя значение ключа и используя это хеш-значение для поиска данных в памяти.
    
2.  Растровые индексы. Растровые индексы используются для быстрой фильтрации данных на основе определенного атрибута или набора атрибутов. Они работают, создавая битовую карту для каждого значения атрибута, где каждый бит соответствует записи в базе данных.
    
3.  Индексы R-Tree: индексы R-Tree используются для эффективного хранения и запроса пространственных данных. Они работают, разделяя пространство на иерархический набор прямоугольников и сохраняя данные в соответствующем прямоугольнике.
    
4.  Инвертированные индексы. Инвертированные индексы используются для быстрого поиска данных по определенному ключевому слову. Они работают, создавая список всех документов, содержащих каждое ключевое слово.
    
5.  Полнотекстовые индексы. Полнотекстовые индексы используются для поиска текстовых данных, таких как статьи или документы. Они работают, индексируя текст и разрешая запросы полнотекстового поиска.
    

Каждый из этих типов индексов имеет свои сильные и слабые стороны, и выбор типа индекса будет зависеть от конкретного варианта использования и требований к данным.

## Какова фундаментальная ценность Unit-тестов по сравнению с интеграционными тестами?
Фундаментальная ценность модульных тестов по сравнению с интеграционными тестами заключается в том, что модульные тесты позволяют разработчикам тестировать отдельные фрагменты кода изолированно, а интеграционные тесты позволяют им проверять, как эти фрагменты работают вместе как система.

Модульные тесты сосредоточены на тестировании небольших изолированных блоков кода, таких как отдельные функции или методы. Они позволяют разработчикам независимо тестировать каждую единицу кода и проверять, правильно ли она работает. Модульные тесты обычно запускаются как часть процесса разработки и могут быть автоматизированы для обеспечения быстрой обратной связи.

Интеграционные тесты, с другой стороны, сосредоточены на проверке того, как различные единицы кода работают вместе, чтобы сформировать систему. Они проверяют взаимодействие и зависимости между различными компонентами, такими как модули или службы, и проверяют, работает ли система должным образом. Интеграционные тесты обычно запускаются после разработки кода и часто используются для проверки критических путей и пограничных случаев.

Фундаментальная ценность модульных тестов заключается в том, что они предоставляют разработчикам быстрый и эффективный способ обнаружения ошибок и багов на ранних этапах процесса разработки. Они позволяют разработчикам выявлять и устранять проблемы до того, как их устранение станет более сложным и дорогостоящим. Тестируя каждую единицу кода изолированно, разработчики могут убедиться, что их код устойчив и надежен, и они могут с уверенностью вносить изменения, зная, что они не вносят новые ошибки и не нарушают существующую функциональность.

Фундаментальная ценность интеграционных тестов заключается в том, что они предоставляют разработчикам возможность проверить, как различные компоненты системы работают вместе. Они позволяют разработчикам убедиться, что система в целом работает правильно и соответствует требованиям пользователей. Интеграционные тесты могут выявить проблемы, которые не могут быть обнаружены модульными тестами, например, проблемы с потоком данных, связью между компонентами или общесистемные проблемы с производительностью.

Таким образом, фундаментальная ценность модульных тестов заключается в том, что они обнаруживают ошибки и баги на ранних этапах процесса разработки, а фундаментальная ценность интеграционных тестов заключается в том, что они проверяют, как различные компоненты системы работают вместе, образуя единое целое. Оба типа тестов важны и должны использоваться вместе для обеспечения качества и надежности программного обеспечения.

## Укажите особенности Интерфейса
В JavaScript интерфейсы не являются встроенной языковой конструкцией, как в некоторых других языках программирования, таких как Java или C#. Однако мы можем использовать определенные шаблоны и соглашения для достижения концепции интерфейсов. Вот некоторые ключевые особенности интерфейсов в JavaScript:

1.  Определение. В JavaScript интерфейс обычно определяется как объект, указывающий методы и свойства, которыми должен обладать реализующий объект.
    
2.  Контракт: Интерфейсы в JavaScript определяют контракт между потребителем объекта и реализацией этого объекта. Контракт определяет поведение, которое потребитель может ожидать от реализации.
    
3.  Полиморфизм: интерфейсы JavaScript позволяют различным объектам реализовывать один и тот же интерфейс, что позволяет взаимозаменяемо использовать эти объекты.
    
4.  Гибкость: интерфейсы JavaScript позволяют разработчикам писать гибкий код, который может работать с множеством различных объектов, если они реализуют интерфейс.
    
5.  Инкапсуляция: интерфейсы JavaScript могут обеспечивать инкапсуляцию, скрывая детали реализации объекта от потребителя и предоставляя доступ только к методам и свойствам, определенным в интерфейсе.
    
6.  Проверка типов: интерфейсы JavaScript можно использовать для проверки типов, чтобы убедиться, что объект реализует требуемые методы и свойства, указанные в интерфейсе.
    
7.  Документация: Интерфейсы в JavaScript можно использовать как форму документации, разъясняя, какие методы и свойства должны быть у объекта, чтобы его можно было правильно использовать.

В целом, интерфейсы в JavaScript предоставляют способ определения и обеспечения соблюдения контрактов между объектами, упрощая написание модульного, многократно используемого и поддерживаемого кода.

## В чем разница между WebSockets и Server-Sent Events/EventSource?
WebSockets и Server-Sent Events/EventSource — это две разные технологии, используемые для связи в реальном времени между клиентом и сервером. Вот некоторые различия между ними:

1.  Двунаправленная связь: WebSockets обеспечивают полнодуплексную связь, что означает, что и клиент, и сервер могут отправлять сообщения в любое время, а Server-Sent Events/EventSource — это протокол односторонней связи, где сервер может отправлять данные клиенту. , но клиент не может отправить данные обратно.
    
2.  Установление соединения: для WebSockets требуется установить полнодуплексное соединение между клиентом и сервером, тогда как события, отправленные сервером, используют простое соединение HTTP и полагаются на сервер для отправки периодических обновлений клиенту.
    
3.  Совместимость: WebSockets поддерживаются во всех современных браузерах, а события, отправленные сервером, не поддерживаются в Internet Explorer и некоторых старых браузерах.
    
4.  Размер полезной нагрузки: события, отправленные сервером, лучше подходят для отправки полезных данных малого и среднего размера, в то время как веб-сокеты могут обрабатывать как малые, так и большие полезные нагрузки.
    
5.  Сложность сервера: WebSockets требуют более сложной серверной инфраструктуры для обработки полнодуплексной связи, в то время как Server-Sent Events проще реализовать на стороне сервера.
    

В целом, WebSockets лучше подходят для приложений, требующих двунаправленной связи в реальном времени, таких как многопользовательские игры или чат-приложения, в то время как Server-Sent Events лучше подходят для приложений, которым требуется односторонний поток данных, таких как новостные ленты или стоковые обновления.

## Что бы вы изменили в TypeScript, если бы могли изменить только одну вещь?
Если бы я мог что-то изменить в TypeScript, я бы улучшил сообщения об ошибках и сделал их более удобными для пользователя. Хотя TypeScript известен своими возможностями проверки типов, сообщения об ошибках, генерируемые компилятором, иногда могут быть трудными для понимания, особенно для новичков или разработчиков, не знакомых с языком.

Улучшение сообщений об ошибках поможет разработчикам быстрее и эффективнее понять проблемы в их коде, что сэкономит время и уменьшит разочарование. Это может включать в себя предоставление дополнительной контекстной информации, более четких объяснений проблем и, возможно, даже предлагаемых исправлений для распространенных ошибок.

В целом, сделать сообщения об ошибках TypeScript более удобными для пользователя было бы ценным улучшением, которое принесет пользу разработчикам всех уровней опыта.

## Назовите некоторые недостатки хэш-индекса.
Хэш-индексы имеют некоторые недостатки по сравнению с другими типами индексов, в том числе:

1.  Запросы с ограниченным диапазоном: хэш-индексы плохо подходят для запросов диапазона, таких как «найти все значения между X и Y». Поскольку хеш-функция случайным образом распределяет значения по индексу, нет гарантии, что значения, расположенные близко друг к другу в индексе, будут находиться близко друг к другу в хеш-пространстве. Это затрудняет эффективное извлечение диапазона значений.
    
2.  Нет поддержки сортировки: хэш-индексы не сортируются, что означает, что данные, возвращаемые из хэш-индекса, не упорядочены каким-либо определенным образом. Это может быть проблемой при попытке получить набор значений в определенном порядке.
    
3.  Использование памяти: хеш-индексы могут использовать много памяти по сравнению с другими типами индексов, поскольку каждая запись индекса должна хранить хэш-значение и указатель на фактические данные. Это может быть проблемой для больших наборов данных, так как индекс может не полностью помещаться в памяти.
    
4.  Коллизии: хэш-индексы полагаются на хеш-функцию для сопоставления значений с записями индекса. В некоторых случаях разные значения могут иметь одно и то же значение хеш-функции, что приводит к конфликту. Это может замедлить поиск по индексу и сделать его менее эффективным.
    
5.  Не подходит для текстового поиска: хэш-индексы не подходят для текстового поиска, так как они предназначены для работы с данными фиксированной длины. Текстовый поиск требует более сложных методов, таких как индексы полнотекстового поиска или инвертированные индексы.

## Когда следует использовать интерфейсы, а когда классы в TypeScript?
В TypeScript интерфейсы и классы служат разным целям и используются в разных контекстах.

Интерфейсы определяют контракт для объекта, определяя форму объекта, свойства и методы, которые он должен иметь, и их типы. Интерфейсы используются для обеспечения того, чтобы разные части кода, взаимодействующие с объектом, имели общее понимание его структуры и поведения.

Интерфейсы особенно полезны в следующих сценариях:

1.  Определение структур данных и объектов определенной формы.
    
2.  Описание сигнатуры функций, гарантирующее, что они принимают определенные аргументы и возвращают определенные значения.
    
3.  Определение контрактов между классами, гарантирующих, что у них есть определенный интерфейс, который может использоваться другими частями кода.

С другой стороны, классы используются для определения объектов, которые имеют как состояние, так и поведение. Класс — это схема создания объектов, которые могут хранить данные (в форме свойств) и выполнять действия (в форме методов).

Классы особенно полезны в следующих сценариях:

1.  Создание объектов с состоянием и поведением, таких как модели, службы или контроллеры.
    
2.  Инкапсуляция функций и данных для создания повторно используемых компонентов.
    
3.  Реализация наследования и полиморфизма для создания иерархии классов с общим поведением и характеристиками.

Таким образом, интерфейсы используются для определения контрактов, которым должны соответствовать объекты, а классы используются для определения объектов, которые имеют как состояние, так и поведение. На практике обычно используют интерфейсы для определения формы данных и контрактов между объектами, а также используют классы для реализации поведения и инкапсуляции данных.

## Когда следует использовать EventEmitter?
В Node.js `EventEmitter`это мощный инструмент для создания приложений, управляемых событиями. Это позволяет вам определять и генерировать пользовательские события и регистрировать прослушиватели для обработки этих событий.

Вот несколько сценариев, в которых использование `EventEmitter`может быть полезным:

1.  **Асинхронная обработка.** Если у вас есть длительная задача, которая должна сообщать о своем ходе или завершении, вы можете использовать `EventEmitter`для отправки событий на разных этапах задачи и регистрации прослушивателей для обработки этих событий. Это может помочь вам сделать ваш код более читабельным и удобным для сопровождения, разбив его на более мелкие, более модульные части.
    
2.  **Серверные приложения:** в серверных приложениях `EventEmitter`может использоваться для обработки входящих запросов и генерации событий при выполнении определенных условий. Например, вы можете генерировать событие при подключении или отключении клиента, при получении запроса или при возникновении ошибки.
    
3.  **Пользовательские события:** если вашему приложению необходимо определять и обрабатывать пользовательские события, `EventEmitter`может быть полезным инструментом. Например, вы можете определить событие, которое будет запускаться, когда пользователь выполняет определенное действие или когда выполняется определенное условие.
    
4.  **Тестирование:** `EventEmitter` также может использоваться для написания более надежных и комплексных тестов. Вы можете использовать его для имитации событий и проверки того, что ожидаемое поведение происходит при генерации этих событий.

В целом, `EventEmitter`это может быть мощным инструментом для создания управляемых событиями асинхронных приложений в Node.js. Это может помочь вам сделать ваш код более модульным, повторно используемым и простым в обслуживании.

## Объясните, что такое паттерн Reactor в Node.js?
Шаблон Reactor — это шаблон проектирования, используемый в Node.js для создания масштабируемых высокопроизводительных сетевых приложений. Он включает однопоточный цикл событий, который ожидает завершения операций ввода-вывода и запускает обратные вызовы, когда они выполняются.

В Node.js цикл обработки событий реализован с помощью библиотеки libuv, которая предоставляет кроссплатформенный API для асинхронного ввода-вывода. Когда приложение Node.js запускается, оно инициализирует цикл событий и регистрирует функции обратного вызова для различных типов событий, таких как входящие соединения, файловый ввод-вывод и события таймера.

Когда операция ввода-вывода инициируется, Node.js передает ее в цикл обработки событий и продолжает выполнение другого кода. Когда операция ввода-вывода завершается, цикл событий запускает зарегистрированную функцию обратного вызова, которая затем может обрабатывать данные или инициировать другую операцию ввода-вывода.

Используя шаблон Reactor, Node.js может обрабатывать большое количество одновременных подключений без использования отдельного потока для каждого подключения. Это позволяет Node.js хорошо масштабироваться на современных многоядерных процессорах и обрабатывать тысячи подключений с относительно низким объемом памяти.

В целом шаблон Reactor — это мощный метод создания высокопроизводительных масштабируемых сетевых приложений в Node.js. Используя однопоточный цикл событий и асинхронный ввод-вывод, Node.js может обрабатывать большие объемы трафика с минимальными накладными расходами, что делает его хорошо подходящим для современных веб-приложений.

## Почему оператор this в JavaScript несогласованный?
Поведение ключевого `this`слова в JavaScript может быть непоследовательным или запутанным, поскольку оно динамически связывается во время выполнения в зависимости от того, как вызывается функция, а не статически привязывается в зависимости от того, где оно определено. Это означает, что значение `this`может меняться в зависимости от контекста, в котором вызывается функция.

Например, когда функция вызывается как метод объекта, `this`ссылается на сам объект. Но когда функция вызывается без явного объекта-приемника, `this`она может ссылаться на глобальный `window`объект (в браузере) или на глобальный `global`объект (в Node.js). Кроме того, значение `this`можно изменить с помощью методов `call`, `apply`, или .`bind`

Эта динамическая привязка `this`может затруднить анализ поведения кода, особенно при работе со сложными иерархиями объектов или API-интерфейсами на основе обратных вызовов. Также может быть сложно поддерживать надлежащий контекст `this`при использовании стрелочных функций или передаче методов в качестве обратных вызовов.

Однако динамическое связывание `this`также может быть мощным инструментом для написания гибкого и многократно используемого кода, например, при реализации объектно-ориентированных шаблонов, таких как примеси или декораторы. Важно понимать, как `this`работает JavaScript, и использовать его правильно и последовательно, чтобы избежать распространенных ошибок и ошибок.

## Что такое Домен в DDD?
В доменно-ориентированном проектировании (DDD) домен — это предметная область или бизнес-контекст, в котором работает приложение. Он определяет концепции, правила и отношения, которые регулируют конкретную проблемную область, такую ​​как электронная коммерция, финансы или здравоохранение.

Домен — это сложная система, включающая людей, процессы, данные и технологии. Он охватывает как функциональные, так и нефункциональные требования к приложению и представляет знания и опыт заинтересованных сторон, вовлеченных в предметную область.

В DDD домен является наиболее важной частью приложения и должен быть в центре внимания процесса проектирования и разработки. Цель состоит в том, чтобы создать модель предметной области, которая точно представляет концепции и правила предметной области и может использоваться в качестве общего языка для общения и сотрудничества между заинтересованными сторонами и командой разработчиков.

Модель предметной области — это структурированное представление предметной области, включающее сущности, объекты-значения, агрегаты, службы и другие концепции, относящиеся к предметной области. Он должен быть максимально простым и выразительным, но при этом отражать сложность и богатство предметной области.

Сосредоточив внимание на предметной области и создав четкую и лаконичную модель предметной области, DDD может помочь разработчикам создавать приложения, которые легче поддерживать, масштабировать и адаптировать к изменяющимся потребностям бизнеса.

## Что такое Связность в ООП?
Связность в объектно-ориентированном программировании (ООП) относится к отношениям между объектами в программной системе. В ООП объекты взаимодействуют друг с другом, отправляя и получая сообщения, и эти взаимодействия определяются связностью между объектами.

В ООП существуют различные типы подключения, в том числе:

1.  Ассоциация: это относится к отношениям между двумя объектами, где один объект является членом другого объекта. Например, объект автомобиля может иметь ассоциацию с объектом водителя, указывающую, что водитель управляет автомобилем.
    
2.  Агрегация: это тип ассоциации, который указывает на взаимосвязь между объектами. Например, у автомобиля может быть агрегация с объектом двигателя, указывающая, что двигатель является частью автомобиля.
    
3.  Композиция: это более сильная форма агрегации, когда части не могут существовать без целого. Например, автомобиль может иметь композицию с объектом рулевого колеса, указывающим на то, что рулевое колесо является неотъемлемой частью автомобиля.
    
4.  Наследование: это механизм создания новых классов путем наследования свойств и поведения существующих классов. Например, автомобиль может наследовать свойства и поведение от класса транспортного средства.
    
5.  Полиморфизм: это относится к взаимозаменяемости объектов разных классов. Например, объект автомобиля может использоваться в методе, который принимает объект транспортного средства, поскольку автомобиль — это тип транспортного средства.
    

Связность — важная концепция ООП, поскольку она позволяет разработчикам создавать гибкие и удобные в сопровождении программные системы. Определяя четкие отношения между объектами, разработчики могут создавать системы, которые легче понять, модифицировать и расширять с течением времени.

## Основан ли Node.js полностью на одном потоке?
Нет, Node.js не полностью основан на одном потоке. В то время как основной цикл событий в Node.js выполняется в одном потоке, Node.js может использовать преимущества нескольких ядер и потоков за счет использования рабочих потоков и других функций.

Node.js предоставляет модуль под названием «кластер», который позволяет разработчикам использовать преимущества нескольких ядер на одном компьютере. Модуль «кластер» позволяет разработчикам создавать дочерние процессы, которые могут быть распределены по нескольким ядрам, но при этом использовать одни и те же серверные порты и прослушивать одни и те же сетевые события. Каждый дочерний процесс может запускать собственный цикл обработки событий, что позволяет Node.js использовать преимущества нескольких ядер и повышать производительность.

Кроме того, Node.js также предоставляет модуль worker_threads, который позволяет разработчикам создавать рабочие потоки и управлять ими. Рабочие потоки похожи на дочерние процессы, но они легче и обеспечивают лучшую связь между потоками. Рабочие потоки полезны для обработки ресурсоемких задач ЦП, таких как обработка изображений или алгоритмы машинного обучения, в потоке, отдельном от основного цикла обработки событий.

В целом, хотя Node.js основан на однопоточном цикле событий, он предоставляет несколько функций и модулей, которые позволяют разработчикам использовать преимущества нескольких ядер и потоков для повышения производительности и масштабируемости.

## Что означает программировать по интерфейсу?
Программирование через интерфейс — это парадигма программирования, которая делает упор на разработку программных компонентов таким образом, чтобы их можно было использовать взаимозаменяемо, если они реализуют один и тот же интерфейс.

В этой парадигме интерфейс определяет набор методов или свойств, которые должен реализовать класс или объект, чтобы считаться совместимым с интерфейсом. Программируя интерфейс, а не реализацию, мы можем писать более гибкий и многократно используемый код, что позволяет нам изменять базовую реализацию, не затрагивая остальную часть системы.

В объектно-ориентированном программировании интерфейсы часто определяются как абстрактные классы или контракты, которые определяют набор методов или свойств, которые должны быть реализованы конкретным классом. Программируя интерфейс, мы можем писать код, который меньше зависит от конкретной реализации и больше ориентирован на функциональность, предоставляемую реализацией.

Программирование через интерфейс часто используется в сочетании с другими принципами программирования, такими как инверсия зависимостей и инверсия управления, для достижения слабой связи между программными компонентами и облегчения тестирования, обслуживания и расширяемости.

## Что такое оператор typeof в JavaScript?
Оператор `typeof`— это встроенный оператор в JavaScript, который возвращает строку, указывающую тип данного операнда.

## Что такое Sharding?
Разделение — это метод, используемый в системах управления базами данных для разделения больших баз данных на более мелкие, более управляемые части, называемые сегментами. Каждый сегмент хранится на отдельном сервере или узле и содержит подмножество данных.

Разделение обычно используется для горизонтального масштабирования, что означает, что в систему добавляется больше компьютеров для обработки возросшей рабочей нагрузки, а не масштабирование по вертикали за счет увеличения ресурсов на одном компьютере. Распределяя данные по нескольким серверам, сегментирование может повысить производительность, увеличить масштабируемость и обеспечить лучшую отказоустойчивость.

В сегментированной системе данные делятся на логические или физические разделы на основе предопределенного ключа сегментирования. Ключ сегментирования выбирается таким образом, чтобы он равномерно распределял данные по сегментам. Осколки можно организовать несколькими способами, например, по диапазону, по хэшу или по комбинации того и другого.

Одной из проблем сегментирования является обеспечение согласованности данных во всех сегментах. Когда данные обновляются, изменения должны распространяться на все соответствующие осколки. Это может быть достигнуто с помощью ряда методов, таких как распределенные транзакции или согласованность в конечном счете. Еще одна проблема заключается в обеспечении эффективного выполнения запросов во всех сегментах, что требует тщательного планирования и оптимизации.

## Что такое Event Loop?
Цикл событий — ключевой компонент Node.js и многих других сред асинхронного программирования. Это механизм, который позволяет приложениям одновременно обрабатывать несколько задач и событий, не блокируя и не замедляя общую работу системы.

В Node.js цикл событий отвечает за управление и выполнение асинхронных задач, таких как операции ввода-вывода или обратные вызовы таймера. Когда задача инициируется, например сетевой запрос, она добавляется в очередь, и цикл обработки событий продолжает обрабатывать следующую задачу в очереди. Когда задача завершена, обратный вызов добавляется в другую очередь, которая аналогичным образом обрабатывается циклом обработки событий.

Цикл событий работает непрерывно, обрабатывая задачи и обратные вызовы по мере их появления. Он разработан, чтобы быть легким и эффективным, и позволяет Node.js обрабатывать большое количество одновременных запросов, не зависая и не отвечая.

Одной из важных особенностей цикла событий является то, что он работает в одном потоке, что делает его подходящим для обработки задач, связанных с вводом-выводом, которые обычно включают ожидание доступности внешних ресурсов, таких как сетевые запросы или дисковый ввод-вывод. операции. Эта модель известна как однопоточная модель неблокирующего ввода-вывода и является ключевой причиной популярности Node.js как платформы для создания масштабируемых высокопроизводительных веб-приложений.

## Что означает Short-Circuiting в TypeScript?
Короткое замыкание — это поведение в TypeScript (и других языках программирования), которое позволяет логическим операторам (таким как `&&`и `||`) оценивать выражения таким образом, чтобы сэкономить время и предотвратить ненужную работу.

В TypeScript логические операторы ведут себя следующим образом:

-   С `&&`оператором, если левая часть выражения оценивается как `false`, правая часть никогда не оценивается, потому что все выражение уже известно как `false`.
-   С `||`оператором, если левая часть выражения оценивается как `true`, правая часть никогда не оценивается, потому что все выражение уже известно как `true`.

Короткое замыкание — это мощная функция, которую можно использовать для оптимизации кода и сокращения ненужной работы.

## Почему для "нижних" уровней приложения хорошо, чтобы они не были осведомлены о "высших"?
Для более низких уровней приложения полезно не знать о более высоких, потому что это способствует разделению задач и инкапсуляции, которые являются важными принципами разработки программного обеспечения.

Разделение задач относится к практике разбиения программной системы на более мелкие, более модульные компоненты, которые выполняют определенные задачи или обязанности. Благодаря этому каждый компонент можно разрабатывать, тестировать и поддерживать независимо, что делает кодовую базу более управляемой и понятной. Когда нижние уровни приложения не знают о более высоких уровнях, это позволяет лучше разделить задачи и помогает гарантировать, что каждый компонент отвечает только за свою собственную конкретную функциональность.

Инкапсуляция — еще один важный принцип, которому способствует такое разделение. Инкапсуляция относится к практике сокрытия деталей реализации и предоставления общедоступного интерфейса, который другие компоненты могут использовать для взаимодействия с объектом или модулем. Отделяя более низкие уровни приложения от более высоких, это обеспечивает большую инкапсуляцию и помогает предотвратить нежелательные зависимости между компонентами.

## Что такое балансировка нагрузки с помощью "Sticky Session"? Что означает "Session Affinity"?
Для более низких уровней приложения полезно не знать о более высоких, потому что это способствует разделению задач и инкапсуляции, которые являются важными принципами разработки программного обеспечения.

Разделение задач относится к практике разбиения программной системы на более мелкие, более модульные компоненты, которые выполняют определенные задачи или обязанности. Благодаря этому каждый компонент можно разрабатывать, тестировать и поддерживать независимо, что делает кодовую базу более управляемой и понятной. Когда нижние уровни приложения не знают о более высоких уровнях, это позволяет лучше разделить задачи и помогает гарантировать, что каждый компонент отвечает только за свою собственную конкретную функциональность.

Инкапсуляция — еще один важный принцип, которому способствует такое разделение. Инкапсуляция относится к практике сокрытия деталей реализации и предоставления общедоступного интерфейса, который другие компоненты могут использовать для взаимодействия с объектом или модулем. Отделяя более низкие уровни приложения от более высоких, это обеспечивает большую инкапсуляцию и помогает предотвратить нежелательные зависимости между компонентами.

## Что такое Оптимистическая блокировка?

## В чем разница между cluster.fork() и child_process.fork() в Node.js?

## Какова цель оператора слияния нулей?

## Что такое V8?

## В чем разница между ES6 Map и WeakMap?

## Определите Temp Table

## Какова связь между классом и объектом?

## Когда следует использовать генераторы в ES6?

## Почему написание программного обеспечения является трудным? Что делает поддержку программного обеспечения сложной?

## Расскажите мне о разнице между HEAD, рабочим деревом и индексом в Git?

## Что такое export default в JavaScript?

## Как индекс базы данных может помочь улучшить производительность?

## Почему использовать WebSocket вместо HTTP?

## В чем разница между INNER JOIN, OUTER JOIN, FULL OUTER JOIN?

## Объясните проектные ссылки и их преимущества.

## Можно ли унаследовать приватные члены класса?

## В чем разница между событием загрузки документа и событием DOMContentLoaded документа?

## Что такое свойство ACID системы?

## Поддерживает ли Node.js многоядерные платформы? И способен ли он использовать все ядра?

## В чем разница между Абстрактной функцией и Виртуальной функцией?

## Что такое обратный вызов (Callback)?

## Что такое Git fork? В чем разница между fork, branch и clone?

## Как можно сохранить одну копию своего утилитарного кода и позволить нескольким компонентам-потребителям использовать и развертывать его?

## Что означает выражение "Fail Early", и когда следует так делать?

## Что такое балансировка нагрузки?

## Почему использовать Buffer вместо двоичной строки для работы с двоичными данными?

## Каковы преимущества возможностей импорта в TypeScript?

## Как использовать несколько CPU/ядер для Redis?

## Объясните понятие "Потоки" своим бабушкам и дедушкам.

## Чем отличается pm2 restart от pm2 reload?

## Объясните политику same-origin («одинаковый источник») в JavaScript.

## В чем разница между ключевым словом private и закрытыми полями (private fields) в TypeScript?

## Когда использовать Redis вместо MongoDB?

## Может ли Node.js использовать другие движки, кроме V8?

## Назовите некоторые преимущества Unit-тестирования для разработчиков, которые вы лично испытали

## Что такое кардинальность индекса и почему это важно?

## Является ли Redis устойчивым хранилищем данных («D» из ACID)?

## Можно ли запустить внешний процесс с помощью Node.js?

## В чем разница между классами и интерфейсами в TypeScript?

## Что такое масштабируемость?

## Что означает взаимодействие с более низкой задержкой?

## Когда следует использовать git stash?

## Стоит ли тратить усилия на Unit-тестирование?

## Какова стоимость использования индекса базы данных?

## В чем разница между setTimeout(fn, 0) и setImmediate(fn)?

## Что такое Type Erasure в TypeScript?

## Объясните, что такое паттерн Arrange-Act-Assert?

## Что такое stream и какие типы потоков доступны в Node.js?

## Объясните концепцию Конструктора

## Как индекс базы данных может повысить производительность?

## Что такое область видимости (Scope) в JavaScript?

## Перечислите встроенные типы в TypeScript.

## Можно ли использовать TypeScript на бэкэнде и как это сделать?

## Как написать unit-тест для объекта с запросами в базу данных?

## Каковы преимущества использования синтаксиса spread в ES6 и в чем он отличается от синтаксиса rest?

## Назовите некоторые Встроенные глобальные объекты в Node.js.

## Когда бы вы использовали import * as X из 'X'?

## Что такое тип объекта (object type) в JavaScript?

## В чем разница между переменной, которая равна: null, undefined или необъявленная? Как бы вы проверили любое из этих состояний?

## Зачем мы используем ключевое слово abstract для классов и их методов в TypeScript?

## Что значит аббревиатура SOLID и каковы ее принципы?

## Что означает техника промисификации (Promisifying) в Node.js?

## Как создать тип-объединение из свойств псевдонима типа или интерфейса в TypeScript?

## Как решить исключение Process out of Memory в Node.js?

## Каковы преимущества использования Node.js?

## Когда использовать тип данных списков в Redis?

## Опишите, что такое шаблон Event Sourcing.


