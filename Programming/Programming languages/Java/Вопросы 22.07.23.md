## Что такое CGI. Плюсы, минусы?  

## Как защитить куки от воровства и от подделки?  

## Какая разница между аутентификацией и авторизацией?  
-   Идентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.
-   Аутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
-   Авторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

## Что такое XSS. Примеры. Как защитить приложение?  
XSS (Cross-Site Scripting) — это тип уязвимости системы безопасности, который позволяет злоумышленнику внедрять вредоносные сценарии на веб-страницы, просматриваемые другими пользователями. Эти сценарии можно использовать для кражи конфиденциальной информации, такой как учетные данные для входа или маркеры сеанса, или для выполнения несанкционированных действий от имени жертвы.

Примеры XSS-атак включают:

1.  Отраженный XSS: этот тип атаки предполагает, что злоумышленник внедряет скрипт в URL-адрес, который затем отражается обратно пользователю. Например, если окно поиска на веб-сайте не проверяет должным образом вводимые пользователем данные, злоумышленник может ввести вредоносный сценарий, который затем отразится в результатах поиска.
    
2.  Сохраненный XSS: этот тип атаки предполагает, что злоумышленник внедряет скрипт, который постоянно хранится на веб-сайте. Это может произойти, если веб-сайт позволяет пользователям отправлять комментарии или сообщения, которые затем отображаются на сайте без надлежащей проверки ввода.
    
3.  XSS на основе DOM: этот тип атаки включает в себя внедрение злоумышленником скрипта, который выполняется браузером жертвы. Это может произойти, когда веб-сайт использует языки сценариев на стороне клиента, такие как JavaScript, и не может должным образом дезинфицировать пользовательский ввод.
    

Чтобы защитить приложение от XSS-атак, разработчики могут реализовать следующие рекомендации:

1.  Проверка входных данных и кодирование выходных данных. Все вводимые пользователем данные должны быть проверены, чтобы гарантировать их безопасное использование, а все выходные данные должны быть закодированы, чтобы предотвратить внедрение вредоносных скриптов.
    
2.  Использовать политику безопасности контента (CSP): CSP — это механизм безопасности, который позволяет разработчикам указывать, какие источники контента разрешено загружать на веб-страницу. Это может помочь предотвратить выполнение вредоносных скриптов.
    
3.  Используйте HTTPS: HTTPS шифрует все данные, передаваемые между клиентом и сервером, что затрудняет перехват данных и манипулирование ими для злоумышленников.
    
4.  Поддерживайте программное обеспечение в актуальном состоянии. Разработчики должны обновлять свое программное обеспечение и библиотеки, чтобы гарантировать исправление любых известных уязвимостей.
    
5.  Используйте инструменты безопасности. Разработчики могут использовать инструменты безопасности, такие как сканеры уязвимостей и инструменты тестирования на проникновение, чтобы выявлять и устранять проблемы безопасности, прежде чем они смогут быть использованы злоумышленниками.

## REST & SOAP  
REST (Representational State Transfer) и SOAP (Simple Object Access Protocol) — это архитектуры веб-сервисов, которые обеспечивают связь между приложениями через Интернет. Однако они различаются по-разному, например:

1.  Протокол связи: SOAP использует XML (расширяемый язык разметки) в качестве формата сообщения и может передаваться с использованием различных протоколов, таких как HTTP, SMTP и TCP. С другой стороны, REST использует более простой формат сообщений, такой как JSON (обозначение объектов JavaScript), и в основном передается через HTTP.
    
2.  Модель «запрос-ответ»: SOAP использует модель обмена сообщениями «запрос-ответ», когда клиент отправляет запрос на сервер, а сервер отправляет ответ. REST, с другой стороны, использует ресурсо-ориентированную архитектуру, в которой клиент запрашивает определенный ресурс (например, документ или изображение) с сервера и получает его в ответ.
    
3.  Состояние: SOAP считается состоянием, что означает, что каждый запрос от клиента содержит всю необходимую информацию для сервера, чтобы обработать запрос, и сервер не полагается на какое-либо предыдущее взаимодействие с клиентом. REST, с другой стороны, считается апатридом, что означает, что каждый запрос от клиента содержит только необходимую информацию для сервера, чтобы обработать запрос, и сервер может полагаться на предыдущие взаимодействия с клиентом.
    
4.  Гибкость: REST часто считается более гибким, чем SOAP, поскольку он может использовать различные форматы данных, такие как XML, JSON и HTML. SOAP, с другой стороны, часто более жесткий и требует соблюдения определенного формата сообщения.
    
5.  Кэширование: REST позволяет кэшировать ответы, что может повысить производительность за счет уменьшения количества запросов, отправляемых на сервер. SOAP не поддерживает кэширование.
    

В целом и REST, и SOAP имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных требований приложения.

## Как бы вы решили какой из REST или SOAP веб сервисов использовать  

## Какие способы для мониторинга веб-приложений в production вы использовали или знаете  

## Как устроен протокол HTTP  

## Как клиенту понять, удался запрос или нет  

## Что нужно отправить браузеру, чтобы перенаправить на другую страницу  

## Как управлять кешированием в HTTP  ?

## Как кэшируются файлы на уровне протокола?
На уровне протокола кэширование файлов реализовано с помощью HTTP-заголовков. Когда пользователь запрашивает файл с веб-сервера, сервер отправляет файл вместе с несколькими заголовками HTTP, которые предоставляют инструкции о том, как файл должен кэшироваться браузером пользователя.

Двумя наиболее важными заголовками HTTP для кэширования являются «Cache-Control» и «Expires». Заголовок «Cache-Control» сообщает браузеру, как долго он должен хранить файл в своем кеше, а заголовок «Expires» указывает дату и время, после которых файл больше не должен считаться действительным и должен быть повторно загружен из сервер.

В дополнение к этим заголовкам существует несколько других заголовков HTTP, которые можно использовать для управления поведением кэширования, например «Last-Modified» и «ETag». Заголовок «Last-Modified» указывает дату и время последнего изменения файла, а заголовок «ETag» предоставляет уникальный идентификатор файла. Эти заголовки используются, чтобы помочь браузеру определить, действителен ли файл в его кеше или его необходимо повторно получить с сервера.

Используя эти HTTP-заголовки, веб-серверы могут контролировать, как файлы кэшируются браузерами пользователей, что может повысить производительность веб-сайта и снизить нагрузку на сервер. Однако веб-разработчики должны быть осторожны при настройке заголовков кэширования, чтобы гарантировать, что пользователям всегда будут предоставляться самые последние версии файлов, особенно часто изменяемых файлов.
## Чем отличаются HTTP и HTTPS  ?
HTTP (протокол передачи гипертекста) и HTTPS (защищенный протокол передачи гипертекста) — это протоколы, используемые для передачи данных через Интернет. Вот основные различия между HTTP и HTTPS:

1.  Безопасность: HTTPS является более безопасным протоколом, чем HTTP. HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных, что затрудняет перехват и чтение данных при передаче злоумышленникам. Напротив, HTTP не предоставляет никаких функций шифрования или безопасности, что упрощает перехват и чтение данных злоумышленниками.
    
2.  Порт: HTTPS использует порт 443 по умолчанию, а HTTP использует порт 80. Это означает, что если веб-сайт использует HTTPS, URL-адрес будет начинаться с «https://», а если он использует HTTP, URL-адрес будет начинаться с «http». //".
    
3.  Сертификат: HTTPS требует, чтобы на сервере был установлен цифровой сертификат, подтверждающий подлинность веб-сайта. Сертификат выдается доверенной третьей стороной, называемой Центром сертификации (ЦС). Это гарантирует, что передаваемые данные попадут к предполагаемому получателю и не будут перехвачены злонамеренной третьей стороной. HTTP не требует цифрового сертификата.
    
4.  Скорость: HTTPS может быть медленнее, чем HTTP, из-за дополнительных накладных расходов, связанных с шифрованием и расшифровкой данных. Это может быть особенно заметно для сайтов с большим количеством запросов, таких как сайты электронной коммерции.

В целом, HTTPS является более безопасным и закрытым протоколом, чем HTTP, но он может быть медленнее и требует больше ресурсов. Веб-сайты, которые обрабатывают конфиденциальные данные, такие как учетные данные для входа или платежная информация, должны использовать HTTPS для защиты пользовательских данных.

## В чем отличие объектно-ориентированного и функционального программирования? 
Объектно-ориентированное программирование (ООП) и функциональное программирование (ФП) — две популярные парадигмы программирования с разными подходами к проектированию и созданию программных систем. Вот некоторые ключевые различия между ООП и ФП:

1.  Основное внимание: объектно-ориентированное программирование основано на концепции объектов, которые являются экземплярами классов, инкапсулирующих данные и поведение. Основное внимание уделяется организации кода вокруг объектов и их взаимодействий. Функциональное программирование, с другой стороны, основано на идее составления функций, которые представляют собой повторно используемые блоки кода, принимающие входные данные и производящие выходные данные. Основное внимание уделяется сочетанию функций и предотвращению побочных эффектов.
    
2.  Управление состоянием: в ООП объекты имеют состояние, которое можно изменить с помощью методов. В FP функции не имеют состояния, то есть они не изменяют внешнее состояние и полагаются только на свои входные данные для получения выходных данных.
    
3.  Поток управления: ООП использует управляющие структуры, такие как циклы и условия, для управления потоком выполнения программы. FP использует рекурсию и функции более высокого порядка для управления выполнением программы.
    
4.  Наследование: ООП допускает наследование, когда подкласс может наследовать свойства и методы от своего родительского класса. FP не использует наследование, а вместо этого полагается на композицию и функции более высокого порядка для достижения аналогичной функциональности.
    
5.  Побочные эффекты: ООП допускает побочные эффекты, такие как изменение состояния вне объекта или метода. FP избегает побочных эффектов и вместо этого делает акцент на чистых функциях, которые не имеют побочных эффектов и всегда возвращают один и тот же результат при одном и том же входе.

В целом ООП и ФП — это два разных подхода к решению проблем с кодом. ООП лучше всего подходит для приложений, требующих сложного управления состоянием и моделирования объектов реального мира, в то время как FP лучше всего подходит для приложений, требующих сложных преобразований данных и математических вычислений. Обе парадигмы имеют свои сильные и слабые стороны и могут эффективно использоваться в различных контекстах.

## Что такое SOLID, DRY, KISS, YAGNI?  
[[SOLID]], [[KISS]], [[DRY]]

## Назовите плюсы и минусы монолитной архитектуры?  
Монолитная архитектура — это подход к построению программных систем, при котором все компоненты приложения тесно интегрированы и развернуты как единое целое. Вот некоторые плюсы и минусы монолитной архитектуры:

Плюсы:

1.  Простота. Монолитная архитектура проще в разработке, развертывании и управлении, чем микросервисы, поскольку для работы используется только одна кодовая база.
    
2.  Производительность: монолитные приложения могут работать быстрее и эффективнее, чем микросервисы, так как отсутствуют накладные расходы, связанные с сетевым взаимодействием между сервисами.
    
3.  Тестирование. Тестирование монолитного приложения может быть проще, чем тестирование микросервисов, поскольку все компоненты находятся в одном месте.
    
4.  Развертывание. Развертывание монолитного приложения может быть проще, чем развертывание микросервисов, поскольку для развертывания и управления требуется только один компонент.
    
5.  Легче защитить: Монолитные приложения легче защитить, поскольку все компоненты находятся в одном месте, и проще контролировать доступ к приложению в целом.

Минусы:

1.  Масштабируемость. Монолитные приложения сложнее масштабировать, чем микросервисы, поскольку все компоненты тесно связаны друг с другом. Это означает, что все приложение необходимо увеличивать или уменьшать как единое целое.
    
2.  Гибкость: монолитные приложения могут быть менее гибкими, чем микросервисы, поскольку изменения в одном компоненте приложения могут повлиять на все приложение.
    
3.  Отказоустойчивость: монолитные приложения могут быть менее отказоустойчивыми, чем микросервисы, поскольку сбой в одном компоненте может вывести из строя все приложение.
    
4.  Разнообразие технологий: монолитные приложения могут быть ограничены с точки зрения разнообразия технологий, поскольку все компоненты должны быть написаны на одном языке и с использованием одного и того же стека технологий.
    
5.  Автономные команды. Над монолитными приложениями труднее работать в группах, поскольку все компоненты тесно связаны друг с другом, и изменения в одном компоненте могут повлиять на все приложение.

В целом, монолитная архитектура может быть хорошим выбором для небольших и простых приложений или приложений, где производительность является главным приоритетом. Однако для более крупных и сложных приложений микросервисы могут быть лучшим выбором, поскольку они обеспечивают большую гибкость и масштабируемость.
## Назовите плюсы и минусы микросервисов?
Микросервисы — это архитектурный подход к созданию программных систем, при котором приложение разбивается на набор небольших, слабо связанных сервисов, которые работают вместе для обеспечения общей функциональности системы. Вот некоторые плюсы и минусы микросервисов:

Плюсы:

1.  Масштабируемость: микросервисы позволяют независимо масштабировать отдельные компоненты приложения в зависимости от спроса, а не масштабировать все приложение целиком. Это упрощает обработку всплесков трафика или использования.
    
2.  Гибкость. Микросервисы упрощают внесение изменений в приложение, поскольку изменения в одном сервисе можно вносить, не затрагивая всю систему. Это также упрощает эксперименты с новыми функциями и технологиями.
    
3.  Изоляция сбоев: если один микросервис выходит из строя, это не обязательно приводит к остановке всего приложения. Это означает, что проблемы могут быть изолированы и решены быстрее.
    
4.  Разнообразие технологий. Микросервисы позволяют использовать разные технологии для разных сервисов, которые можно выбирать в зависимости от конкретных требований каждого сервиса.
    
5.  Автономные команды. Микросервисы позволяют автономным командам работать над разными сервисами независимо друг от друга, что может повысить производительность и упростить процесс разработки.

Минусы:

1.  Сложность. Микросервисы вносят дополнительную сложность, поскольку приходится управлять большим количеством движущихся частей. Это может затруднить сборку, развертывание и мониторинг приложения.
    
2.  Повышенная задержка. Поскольку микросервисы обмениваются данными по сети, существует возможность увеличения задержки по сравнению с монолитными приложениями, где все компоненты находятся в одном месте.
    
3.  Распределенное управление данными. При использовании микросервисов данные часто распределяются между несколькими сервисами, что усложняет управление и обеспечение согласованности.
    
4.  Тестирование. Тестирование становится более сложным для микросервисов, поскольку каждый сервис необходимо тестировать независимо, а также в сочетании с другими сервисами.
    
5.  Развертывание. Развертывание микросервисов может быть более сложным, чем развертывание монолитного приложения, поскольку требуется развертывание и управление большим количеством компонентов. 

В целом, микросервисы могут быть мощным инструментом для создания больших и сложных приложений, но для их эффективной реализации требуется тщательное рассмотрение и планирование.
