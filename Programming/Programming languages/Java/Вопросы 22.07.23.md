## Что такое CGI. Плюсы, минусы?  
CGI (общий интерфейс шлюза) — это стандартный протокол, позволяющий веб-серверам выполнять программы или сценарии на сервере в ответ на запросы клиентов. Когда клиент запрашивает сценарий CGI, сервер запускает сценарий и возвращает результат клиенту в виде веб-страницы.

Плюсы компьютерной графики:

1.  Независимость от платформы: сценарии CGI могут быть написаны на любом языке программирования, что делает их независимыми от платформы и гибкими.
    
2.  Совместимость: сценарии CGI совместимы практически с любым программным обеспечением веб-сервера и операционной системой.
    
3.  Настройка: сценарии CGI можно настроить в соответствии с конкретными потребностями и требованиями.
    
4.  Доступ к системным ресурсам: сценарии CGI могут получать доступ к системным ресурсам, таким как базы данных или файловые системы, что может быть полезно для веб-приложений, требующих обработки или хранения данных.
    

Минусы CGI:

1.  Производительность: сценарии CGI могут работать медленно, особенно для больших или сложных веб-приложений. Каждый запрос CGI создает новый процесс на сервере, что может замедлить время отклика.
    
2.  Безопасность: сценарии CGI могут представлять угрозу безопасности, если они не защищены или не проверены должным образом. Например, злоумышленник может внедрить вредоносный код в сценарий CGI и выполнить его на сервере.
    
3.  Масштабируемость. Сценарии CGI могут быть трудно масштабируемы для обработки высоких уровней трафика. Каждый запрос CGI создает новый процесс, который может быстро исчерпать ресурсы сервера.
    
4.  Обслуживание: CGI-скрипты могут быть трудны в обслуживании с течением времени, особенно по мере усложнения веб-приложений.
    

В целом, хотя CGI может быть гибким и настраиваемым решением для разработки веб-приложений, его проблемы с производительностью, безопасностью, масштабируемостью и обслуживанием заставили многих разработчиков искать альтернативные решения, такие как языки сценариев на стороне сервера или веб-фреймворки, которые обеспечивают более высокую производительность. эффективный и безопасный подход к веб-разработке.

---

Обобщенный алгоритм работы через CGI можно представить в следующем виде:

1.  Клиент запрашивает CGI-приложение по его URI.
2.  Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.
3.  Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
4.  CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
5.  Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
6.  Веб-сервер передает результаты запроса клиенту.
CGI — это не язык программирования! Это простой протокол, позволяющий веб-серверу передавать данные через stdin и читать их из stdout. Поэтому в качестве CGI-обработчика может использоваться любая серверная программа, способная работать со стандартными потоками ввода-вывода.

## Как защитить куки от воровства и от подделки?  
Файлы cookie — это небольшие фрагменты данных, которые веб-сайт сохраняет на компьютере пользователя. Они часто используются для хранения информации о сеансе или пользовательских настройках. Однако файлы cookie могут быть уязвимы для кражи и подделки, что может привести к несанкционированному доступу к учетной записи пользователя или конфиденциальной информации. Вот несколько шагов для защиты файлов cookie от кражи и подделки:

1.  Использовать HTTPS. Использование HTTPS гарантирует, что все данные, передаваемые между браузером пользователя и сервером, будут зашифрованы. Это значительно усложняет перехват и кражу файлов cookie злоумышленниками.
    
2.  Установите флаги Secure и HttpOnly. Установка флагов Secure и HttpOnly для файлов cookie помогает защитить их от кражи и подделки. Флаг Secure гарантирует, что файл cookie может быть передан только через HTTPS, а флаг HttpOnly предотвращает доступ JavaScript к файлу cookie. Это может предотвратить атаки межсайтового скриптинга (XSS), которые злоумышленники часто используют для кражи файлов cookie.
    
3.  Используйте токены CSRF: подделка межсайтовых запросов (CSRF) — это тип атаки, которая обманом заставляет пользователя сделать запрос, который он не собирался делать. Использование токенов CSRF может помочь защититься от этих типов атак, включив токен в каждый запрос, который проверяется сервером. Это гарантирует, что запрос является законным и не сгенерирован злоумышленником.
    
4.  Реализуйте правильное управление сеансом: файлы cookie часто используются для хранения информации о сеансе, например идентификатора сеанса. Важно убедиться, что идентификаторы сеансов уникальны и непредсказуемы. Кроме того, идентификаторы сеансов должны восстанавливаться после входа или выхода пользователя, чтобы предотвратить атаки фиксации сеанса.
    
5.  Регулярный мониторинг и аудит: важно регулярно отслеживать и проверять ваше веб-приложение на наличие уязвимостей, которые могут позволить украсть или подделать файлы cookie. Это может включать сканирование уязвимостей, тестирование на проникновение и проверку кода.
    

Следуя этим шагам, вы поможете защитить файлы cookie от кражи и подделки, а также обезопасите конфиденциальную информацию своих пользователей.

## Какая разница между аутентификацией и авторизацией?  
-   Идентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.
-   Аутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
-   Авторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

-   Для начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это **идентификация**.
-   После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это **[аутентификация](https://encyclopedia.kaspersky.ru/glossary/authentication/)**.
-   Скорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это **[двухфакторная аутентификация](https://encyclopedia.kaspersky.ru/glossary/two-factor-authentication/)**.
-   После этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — это **[авторизация](https://encyclopedia.kaspersky.ru/glossary/authorization/)**.

## Что такое XSS. Примеры. Как защитить приложение?  
XSS (Cross-Site Scripting) — это тип уязвимости системы безопасности, который позволяет злоумышленнику внедрять вредоносные сценарии на веб-страницы, просматриваемые другими пользователями. Эти сценарии можно использовать для кражи конфиденциальной информации, такой как учетные данные для входа или маркеры сеанса, или для выполнения несанкционированных действий от имени жертвы.

Примеры XSS-атак включают:

1.  Отраженный XSS: этот тип атаки предполагает, что злоумышленник внедряет скрипт в URL-адрес, который затем отражается обратно пользователю. Например, если окно поиска на веб-сайте не проверяет должным образом вводимые пользователем данные, злоумышленник может ввести вредоносный сценарий, который затем отразится в результатах поиска.
    
2.  Сохраненный XSS: этот тип атаки предполагает, что злоумышленник внедряет скрипт, который постоянно хранится на веб-сайте. Это может произойти, если веб-сайт позволяет пользователям отправлять комментарии или сообщения, которые затем отображаются на сайте без надлежащей проверки ввода.
    
3.  XSS на основе DOM: этот тип атаки включает в себя внедрение злоумышленником скрипта, который выполняется браузером жертвы. Это может произойти, когда веб-сайт использует языки сценариев на стороне клиента, такие как JavaScript, и не может должным образом дезинфицировать пользовательский ввод.

Чтобы защитить приложение от XSS-атак, разработчики могут реализовать следующие рекомендации:

1.  Проверка входных данных и кодирование выходных данных. Все вводимые пользователем данные должны быть проверены, чтобы гарантировать их безопасное использование, а все выходные данные должны быть закодированы, чтобы предотвратить внедрение вредоносных скриптов.
    
2.  Использовать политику безопасности контента (CSP): CSP — это механизм безопасности, который позволяет разработчикам указывать, какие источники контента разрешено загружать на веб-страницу. Это может помочь предотвратить выполнение вредоносных скриптов.
    
3.  Используйте HTTPS: HTTPS шифрует все данные, передаваемые между клиентом и сервером, что затрудняет перехват данных и манипулирование ими для злоумышленников.
    
4.  Поддерживайте программное обеспечение в актуальном состоянии. Разработчики должны обновлять свое программное обеспечение и библиотеки, чтобы гарантировать исправление любых известных уязвимостей.
    
5.  Используйте инструменты безопасности. Разработчики могут использовать инструменты безопасности, такие как сканеры уязвимостей и инструменты тестирования на проникновение, чтобы выявлять и устранять проблемы безопасности, прежде чем они смогут быть использованы злоумышленниками.

## REST & SOAP  
REST (Representational State Transfer) и SOAP (Simple Object Access Protocol) — это архитектуры веб-сервисов, которые обеспечивают связь между приложениями через Интернет. Однако они различаются по-разному, например:

_GET_/_POST_/_PUT_/PATCH/DELETE

1.  Протокол связи: SOAP использует XML (расширяемый язык разметки) в качестве формата сообщения и может передаваться с использованием различных протоколов, таких как HTTP, SMTP и TCP. С другой стороны, REST использует более простой формат сообщений, такой как JSON (обозначение объектов JavaScript), и в основном передается через HTTP.
    
2.  Модель «запрос-ответ»: SOAP использует модель обмена сообщениями «запрос-ответ», когда клиент отправляет запрос на сервер, а сервер отправляет ответ. REST, с другой стороны, использует ресурсо-ориентированную архитектуру, в которой клиент запрашивает определенный ресурс (например, документ или изображение) с сервера и получает его в ответ.
    
3.  Состояние: SOAP считается состоянием, что означает, что каждый запрос от клиента содержит всю необходимую информацию для сервера, чтобы обработать запрос, и сервер не полагается на какое-либо предыдущее взаимодействие с клиентом. REST, с другой стороны, считается апатридом, что означает, что каждый запрос от клиента содержит только необходимую информацию для сервера, чтобы обработать запрос, и сервер может полагаться на предыдущие взаимодействия с клиентом.
    
4.  Гибкость: REST часто считается более гибким, чем SOAP, поскольку он может использовать различные форматы данных, такие как XML, JSON и HTML. SOAP, с другой стороны, часто более жесткий и требует соблюдения определенного формата сообщения.
    
5.  Кэширование: REST позволяет кэшировать ответы, что может повысить производительность за счет уменьшения количества запросов, отправляемых на сервер. SOAP не поддерживает кэширование.

В целом и REST, и SOAP имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных требований приложения.

---
SOAP — протокол, а REST — архитектурный стиль, набор правил по написанию кода. REST был представлен в 2000 году. К этому времени недостатки SOAP были очевидны:

-   объемные сообщения;
-   поддержка только одного формата — XML;
-   схема работы по принципу «один запрос — один ответ»;
-   смена описания веб-сервиса может нарушить работу клиента.

Несмотря на простоту использования, у REST есть ряд недостатков, которые отсутствуют у SOAP:

-   при использовании REST сложнее обеспечить безопасность конфиденциальных данных;
-   трудности с проведением операций, которым необходимо сохранение состояния. Как, например, в случае с корзиной в онлайн-магазине, которая должна сохранять добавленные товары до момента оплаты.

 В каких случаях используют SOAP
-   Асинхронная обработка и последующий вызов. Стандарт SOAP 1.2 обеспечивает клиенту гарантированный уровень надежности и безопасности.
-   Формальное средство коммуникации. Если клиент и сервер имеют соглашение о формате обмена, то SOAP 1.2 предоставляет жесткие спецификации для такого типа взаимодействия. Пример — сайт онлайн-покупок, на котором пользователи добавляют товары в корзину перед оплатой. Предположим, что есть веб-служба, которая выполняет окончательный платеж. Может быть достигнуто соглашение, что веб-сервис будет принимать только название товара, цену за единицу и количество. Если сценарий существует, лучше использовать протокол SOAP.
-   Операции с состоянием. Если приложение требует, чтобы состояние сохранялось от одного запроса к другому, то стандарт SOAP 1.2 предоставляет структуру для поддержки таких требований.

## Как бы вы решили какой из REST или SOAP веб сервисов использовать  
При принятии решения об использовании веб-службы REST или SOAP необходимо учитывать несколько факторов:

1.  Протокол связи: веб-службы REST, как правило, проще в использовании, поскольку они основаны на простых форматах сообщений, таких как JSON, тогда как SOAP использует XML, с которым может быть сложнее работать. Если протокол связи является важным фактором, REST может быть лучшим выбором.
    
2.  Ориентация на ресурсы. Веб-службы REST разрабатываются с учетом ресурсов, что упрощает работу с данными и их организацию. Если данные, с которыми вы работаете, ориентированы на ресурсы, REST может быть лучшим выбором.
    
3.  Отслеживание состояния: веб-службы REST не имеют состояния, что означает, что они не полагаются на предыдущие взаимодействия между клиентом и сервером. Если безгражданство важно для вашего приложения, REST может быть лучшим выбором.
    
4.  Гибкость: веб-службы REST, как правило, более гибкие, чем SOAP, поскольку они могут использовать различные форматы данных. Если гибкость важна, REST может быть лучшим выбором.
    
5.  Существующая инфраструктура. Если у вас есть существующая инфраструктура, использующая SOAP, может быть проще придерживаться SOAP. Точно так же, если у вас есть существующая инфраструктура, использующая REST, может быть проще придерживаться REST.
    

В конечном итоге выбор между REST или SOAP будет зависеть от конкретных требований вашего приложения. При принятии решения важно учитывать такие факторы, как протокол связи, ориентация на ресурсы, сохранение состояния, гибкость и существующая инфраструктура.

## Какие способы для мониторинга веб-приложений в production вы использовали или знаете  
Есть несколько методов мониторинга веб-приложений в производстве, которые я использовал или знаю:

1.  Ведение журнала. Ведение журнала — это процесс записи событий и действий в веб-приложении. Регистрируя различные события, такие как ошибки, предупреждения или взаимодействия с пользователем, вы можете получить ценную информацию о том, как работает ваше веб-приложение. Ведение журнала может выполняться на разных уровнях, включая приложения, веб-сервер и операционную систему.
    
2.  Мониторинг производительности. Мониторинг производительности включает измерение ключевых показателей производительности, таких как время отклика, частота запросов, использование ЦП, использование памяти и сетевой трафик. Это может помочь выявить узкие места в производительности и другие проблемы, которые могут повлиять на работу пользователей.
    
3.  Проверки работоспособности. Проверки работоспособности — это автоматические тесты, проверяющие функциональность веб-приложения. Выполняя проверки работоспособности на регулярной основе, вы можете убедиться, что ваше веб-приложение работает должным образом, и быстро выявить любые проблемы.
    
4.  Оповещение. Оповещение включает в себя настройку уведомлений, чтобы предупредить вас о срабатывании определенных событий или пороговых значений. Например, вы можете настроить оповещение, чтобы уведомлять вас, когда время отклика вашего веб-приложения превышает определенный порог.
    
5.  Трассировка. Трассировка включает в себя отслеживание потока запросов через веб-приложение. Отслеживая запросы, вы можете выявить узкие места и проблемы с производительностью и оптимизировать производительность вашего приложения.
    
6.  Синтетический мониторинг. Синтетический мониторинг включает в себя моделирование взаимодействия пользователя с веб-приложением для отслеживания его доступности и производительности. Это может помочь выявить проблемы до того, как они повлияют на реальных пользователей.
    
7.  Мониторинг реального пользователя. Мониторинг реального пользователя включает в себя мониторинг фактического взаимодействия пользователей с веб-приложением. Это может дать представление о том, как пользователи взаимодействуют с вашим приложением, и определить любые проблемы, с которыми они могут столкнуться.

Для реализации этих методов доступно множество инструментов и сервисов, включая решения с открытым исходным кодом, такие как Prometheus, Grafana и ELK stack, а также коммерческие решения, такие как New Relic, Datadog и AppDynamics.

Существует несколько инструментов для мониторинга веб-приложений в рабочей среде. Вот некоторые из самых популярных:

1.  New Relic: New Relic — это облачная платформа для мониторинга, которая предоставляет информацию о веб-приложениях в режиме реального времени. Он предоставляет показатели производительности, отслеживание ошибок и транзакций для приложений, работающих в различных средах, включая облачные платформы, такие как AWS и Azure.
    
2.  Datadog: Datadog — это облачная платформа мониторинга и аналитики, которая обеспечивает единое представление об инфраструктуре и производительности приложений. Он включает в себя такие функции, как информационные панели в реальном времени, оповещения и обнаружение аномалий, а также интеграцию с популярными платформами и службами веб-приложений.
    
3.  Prometheus: Prometheus — это система мониторинга с открытым исходным кодом, которая широко используется для мониторинга контейнерных приложений. Он предоставляет гибкий язык запросов, настраиваемые информационные панели и множество интеграций с популярными платформами и службами веб-приложений.
    
4.  Nagios: Nagios — это система мониторинга с открытым исходным кодом, которую можно использовать для мониторинга широкого спектра систем и приложений, включая веб-приложения. Он предоставляет настраиваемую архитектуру плагинов, возможности оповещения и отчетности.
    
5.  ELK Stack: ELK Stack представляет собой набор инструментов с открытым исходным кодом, включая Elasticsearch, Logstash и Kibana, которые можно использовать для мониторинга и анализа данных журналов из веб-приложений. Он обеспечивает визуализацию и анализ данных журнала в режиме реального времени, а также возможность настройки предупреждений и информационных панелей.
    
6.  Graylog: Graylog — это платформа управления журналами с открытым исходным кодом, которую можно использовать для сбора, хранения и анализа данных журналов из веб-приложений. Он предоставляет возможности поиска и анализа в реальном времени, а также возможность настраивать оповещения и информационные панели.

## Как устроен протокол HTTP  
Протокол передачи гипертекста (HTTP) — это протокол прикладного уровня, используемый для связи между веб-серверами и клиентами. Протокол работает по модели «запрос-ответ», где клиенты отправляют запросы на серверы, а серверы отвечают сообщением.

Вот как работает протокол HTTP:

1.  Клиент отправляет запрос: клиент, обычно веб-браузер, отправляет запрос на веб-сервер для получения веб-страницы или ресурса. Запрос состоит из метода (например, GET, POST или PUT), универсального идентификатора ресурса (URI), который идентифицирует ресурс, и набора заголовков, предоставляющих дополнительную информацию о запросе.
    
2.  Сервер обрабатывает запрос: сервер получает запрос, обрабатывает его и формирует ответ. Сервер может выполнить сценарий или получить данные из базы данных, чтобы сгенерировать ответ.
    
3.  Сервер отправляет ответ: сервер отправляет ответ клиенту, который состоит из строки состояния, заголовков и тела сообщения. Строка состояния содержит код состояния, например 200 OK или 404 Not Found, указывающий на состояние запроса. Заголовки предоставляют дополнительную информацию об ответе, например тип содержимого и длину, а тело сообщения содержит запрошенные данные.
    
4.  Клиент получает ответ: клиент получает ответ и отображает содержимое пользователю. Если ответ содержит HTML, браузер анализирует HTML и отображает веб-страницу.
    
5.  Соединение закрывается: после отправки ответа соединение между клиентом и сервером закрывается. Если клиенту необходимо запросить дополнительные ресурсы, он открывает новое соединение и отправляет новый запрос.
    

HTTP — это протокол без сохранения состояния, что означает, что каждый запрос и ответ не зависят от всех остальных. Для сохранения состояния между запросами веб-приложения часто используют файлы cookie или другие механизмы для хранения информации о сеансе. Протокол HTTPS — это безопасная версия HTTP, использующая шифрование для защиты конфиденциальных данных, передаваемых между клиентами и серверами.
![A basic HTTP request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png)
![](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png)
## Как клиенту понять, удался запрос или нет  
Клиент может узнать, был ли запрос успешным или нет, проверив код состояния HTTP, включенный в ответ от сервера.

Коды состояния HTTP — это трехзначные числа, указывающие на состояние ответа сервера на запрос клиента. Наиболее распространенные коды состояния HTTP:
- 1xx: Информационные. 
100 - "Продолжить". Этот промежуточный ответ указывает, что запрос успешно принят и клиент может продолжать присылать запросы либо проигнорировать этот ответ, если запрос был завершён.
101 - "Переключение протокола".
102 - "В обработке".

-   2xx Success: запрос был выполнен успешно, и сервер отправил ответ.
    
-   Перенаправление 3xx: клиент должен предпринять дополнительные действия для выполнения запроса, например выполнить перенаправление.
    
-   4xx Ошибка клиента: запрос был неправильно сформирован или недействителен, и сервер не смог его обработать.
    
-   5xx Ошибка сервера: сервер обнаружил ошибку при обработке запроса.
    

Например, если клиент отправляет запрос GET для получения веб-страницы, а сервер успешно возвращает страницу, ответ будет содержать код состояния HTTP 200 OK. Если клиент отправляет запрос POST для отправки формы, а сервер успешно обрабатывает данные формы, ответ может включать код состояния HTTP 201 Created.

Если сервер обнаруживает ошибку при обработке запроса, он возвращает код состояния HTTP, указывающий на ошибку. Например, если клиент запрашивает несуществующий ресурс, сервер вернет код состояния HTTP 404 Not Found.

Клиент может проверить код состояния HTTP ответа сервера, чтобы определить, был ли запрос успешным или нет. В зависимости от приложения клиент может отображать соответствующее сообщение или выполнять дополнительные действия на основе кода состояния.

## Что нужно отправить браузеру, чтобы перенаправить на другую страницу  
Чтобы перенаправить браузер на другую страницу, серверу необходимо отправить HTTP-ответ с кодом состояния 3xx (перенаправление) и заголовком Location, в котором указан URL-адрес новой страницы.
<?php
header("HTTP/1.1 301 Moved Permanently");
header("Location: https://www.example.com/newpage.html");
exit();
?>
В этом примере функция PHP `header()`используется для установки кода состояния ответа HTTP на 301 (перемещено навсегда) и заголовка местоположения на URL-адрес новой страницы. Эта `exit()`функция используется для завершения сценария и предотвращения отправки любого дополнительного вывода в браузер.

Когда браузер получает этот ответ, он автоматически перенаправляет на новую страницу, указанную в заголовке Location.

## Как управлять кешированием в HTTP  ?
[[HTTP-кеширование]]
Управление кэшированием в HTTP включает настройку соответствующих заголовков кэширования в ответе HTTP, отправляемом с сервера в браузер клиента. Вот некоторые распространенные заголовки кэширования и способы их использования:

1.  Cache-Control: этот заголовок позволяет указать, как долго ответ может кэшироваться. Значения, которые вы можете использовать для этого заголовка:
    
    -   max-age: указывает количество секунд, в течение которых ответ может кэшироваться.
    -   no-cache: указывает, что ответ не должен кэшироваться, но может быть сохранен браузером для использования в будущем.
    -   no-store: указывает, что ответ не должен кэшироваться или сохраняться браузером.
2.  Expires: этот заголовок указывает дату и время, после которых ответ считается устаревшим и больше не должен обслуживаться из кеша.
    
3.  ETag: этот заголовок предоставляет уникальный идентификатор ответа, который можно использовать для проверки того, изменился ли ответ с момента его последнего кэширования.
    
4.  Last-Modified: этот заголовок указывает дату и время последнего изменения ответа.

Вот несколько советов по управлению кэшированием в HTTP:

1.  Установите соответствующие значения для заголовка Cache-Control на основе содержимого ответа. Например, статические файлы, такие как изображения или файлы CSS, могут кэшироваться на более длительный период времени, чем динамическое содержимое, такое как HTML-страницы.
    
2.  Используйте заголовок Last-Modified, чтобы проверить, был ли изменен ответ с момента его последнего кэширования. Если ответ не был изменен, сервер может отправить ответ 304 Not Modified, который сообщает клиенту использовать свою кешированную версию ответа.
    
3.  Используйте заголовок ETag для более детальной проверки того, был ли изменен ответ. Значение ETag должно быть уникальным для конкретной версии ответа.
    
4.  Используйте значения no-cache или no-store Cache-Control для ответов, которые никогда не следует кэшировать, например ответов, содержащих конфиденциальные данные.

Управляя кэшированием в HTTP, вы можете повысить производительность веб-сайта, снизив нагрузку на сервер и минимизировав объем данных, которые необходимо передавать по сети.
## Как кэшируются файлы на уровне протокола?
На уровне протокола кэширование файлов реализовано с помощью HTTP-заголовков. Когда пользователь запрашивает файл с веб-сервера, сервер отправляет файл вместе с несколькими заголовками HTTP, которые предоставляют инструкции о том, как файл должен кэшироваться браузером пользователя.

Двумя наиболее важными заголовками HTTP для кэширования являются «Cache-Control» и «Expires». Заголовок «Cache-Control» сообщает браузеру, как долго он должен хранить файл в своем кеше, а заголовок «Expires» указывает дату и время, после которых файл больше не должен считаться действительным и должен быть повторно загружен из сервер.

В дополнение к этим заголовкам существует несколько других заголовков HTTP, которые можно использовать для управления поведением кэширования, например «Last-Modified» и «ETag». Заголовок «Last-Modified» указывает дату и время последнего изменения файла, а заголовок «ETag» предоставляет уникальный идентификатор файла. Эти заголовки используются, чтобы помочь браузеру определить, действителен ли файл в его кеше или его необходимо повторно получить с сервера.

Используя эти HTTP-заголовки, веб-серверы могут контролировать, как файлы кэшируются браузерами пользователей, что может повысить производительность веб-сайта и снизить нагрузку на сервер. Однако веб-разработчики должны быть осторожны при настройке заголовков кэширования, чтобы гарантировать, что пользователям всегда будут предоставляться самые последние версии файлов, особенно часто изменяемых файлов.
## Чем отличаются HTTP и HTTPS  ?
HTTP (протокол передачи гипертекста) и HTTPS (защищенный протокол передачи гипертекста) — это протоколы, используемые для передачи данных через Интернет. Вот основные различия между HTTP и HTTPS:

1.  Безопасность: HTTPS является более безопасным протоколом, чем HTTP. HTTPS использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных, что затрудняет перехват и чтение данных при передаче злоумышленникам. Напротив, HTTP не предоставляет никаких функций шифрования или безопасности, что упрощает перехват и чтение данных злоумышленниками.
    
2.  Порт: HTTPS использует порт 443 по умолчанию, а HTTP использует порт 80. Это означает, что если веб-сайт использует HTTPS, URL-адрес будет начинаться с «https://», а если он использует HTTP, URL-адрес будет начинаться с «http». //".
    
3.  Сертификат: HTTPS требует, чтобы на сервере был установлен цифровой сертификат, подтверждающий подлинность веб-сайта. Сертификат выдается доверенной третьей стороной, называемой Центром сертификации (ЦС). Это гарантирует, что передаваемые данные попадут к предполагаемому получателю и не будут перехвачены злонамеренной третьей стороной. HTTP не требует цифрового сертификата.
    
4.  Скорость: HTTPS может быть медленнее, чем HTTP, из-за дополнительных накладных расходов, связанных с шифрованием и расшифровкой данных. Это может быть особенно заметно для сайтов с большим количеством запросов, таких как сайты электронной коммерции.

В целом, HTTPS является более безопасным и закрытым протоколом, чем HTTP, но он может быть медленнее и требует больше ресурсов. Веб-сайты, которые обрабатывают конфиденциальные данные, такие как учетные данные для входа или платежная информация, должны использовать HTTPS для защиты пользовательских данных.

## В чем отличие объектно-ориентированного и функционального программирования? 
Объектно-ориентированное программирование (ООП) и функциональное программирование (ФП) — две популярные парадигмы программирования с разными подходами к проектированию и созданию программных систем. Вот некоторые ключевые различия между ООП и ФП:

1.  Основное внимание: объектно-ориентированное программирование основано на концепции объектов, которые являются экземплярами классов, инкапсулирующих данные и поведение. Основное внимание уделяется организации кода вокруг объектов и их взаимодействий. Функциональное программирование, с другой стороны, основано на идее составления функций, которые представляют собой повторно используемые блоки кода, принимающие входные данные и производящие выходные данные. Основное внимание уделяется сочетанию функций и предотвращению побочных эффектов.
    
2.  Управление состоянием: в ООП объекты имеют состояние, которое можно изменить с помощью методов. В FP функции не имеют состояния, то есть они не изменяют внешнее состояние и полагаются только на свои входные данные для получения выходных данных.
    
3.  Поток управления: ООП использует управляющие структуры, такие как циклы и условия, для управления потоком выполнения программы. FP использует рекурсию и функции более высокого порядка для управления выполнением программы.
    
4.  Наследование: ООП допускает наследование, когда подкласс может наследовать свойства и методы от своего родительского класса. FP не использует наследование, а вместо этого полагается на композицию и функции более высокого порядка для достижения аналогичной функциональности.
    
5.  Побочные эффекты: ООП допускает побочные эффекты, такие как изменение состояния вне объекта или метода. FP избегает побочных эффектов и вместо этого делает акцент на чистых функциях, которые не имеют побочных эффектов и всегда возвращают один и тот же результат при одном и том же входе.

В целом ООП и ФП — это два разных подхода к решению проблем с кодом. ООП лучше всего подходит для приложений, требующих сложного управления состоянием и моделирования объектов реального мира, в то время как FP лучше всего подходит для приложений, требующих сложных преобразований данных и математических вычислений. Обе парадигмы имеют свои сильные и слабые стороны и могут эффективно использоваться в различных контекстах.

## Что такое SOLID, DRY, KISS, YAGNI?  
[[SOLID]], [[KISS]], [[DRY]], [[YAGNI]]

## Назовите плюсы и минусы монолитной архитектуры?  
Монолитная архитектура — это подход к построению программных систем, при котором все компоненты приложения тесно интегрированы и развернуты как единое целое. Вот некоторые плюсы и минусы монолитной архитектуры:

Плюсы:

1.  Простота. Монолитная архитектура проще в разработке, развертывании и управлении, чем микросервисы, поскольку для работы используется только одна кодовая база.
    
2.  Производительность: монолитные приложения могут работать быстрее и эффективнее, чем микросервисы, так как отсутствуют накладные расходы, связанные с сетевым взаимодействием между сервисами.
    
3.  Тестирование. Тестирование монолитного приложения может быть проще, чем тестирование микросервисов, поскольку все компоненты находятся в одном месте.
    
4.  Развертывание. Развертывание монолитного приложения может быть проще, чем развертывание микросервисов, поскольку для развертывания и управления требуется только один компонент.
    
5.  Легче защитить: Монолитные приложения легче защитить, поскольку все компоненты находятся в одном месте, и проще контролировать доступ к приложению в целом.

Минусы:

1.  Масштабируемость. Монолитные приложения сложнее масштабировать, чем микросервисы, поскольку все компоненты тесно связаны друг с другом. Это означает, что все приложение необходимо увеличивать или уменьшать как единое целое.
    
2.  Гибкость: монолитные приложения могут быть менее гибкими, чем микросервисы, поскольку изменения в одном компоненте приложения могут повлиять на все приложение.
    
3.  Отказоустойчивость: монолитные приложения могут быть менее отказоустойчивыми, чем микросервисы, поскольку сбой в одном компоненте может вывести из строя все приложение.
    
4.  Разнообразие технологий: монолитные приложения могут быть ограничены с точки зрения разнообразия технологий, поскольку все компоненты должны быть написаны на одном языке и с использованием одного и того же стека технологий.
    
5.  Автономные команды. Над монолитными приложениями труднее работать в группах, поскольку все компоненты тесно связаны друг с другом, и изменения в одном компоненте могут повлиять на все приложение.

В целом, монолитная архитектура может быть хорошим выбором для небольших и простых приложений или приложений, где производительность является главным приоритетом. Однако для более крупных и сложных приложений микросервисы могут быть лучшим выбором, поскольку они обеспечивают большую гибкость и масштабируемость.
## Назовите плюсы и минусы микросервисов?
Микросервисы — это архитектурный подход к созданию программных систем, при котором приложение разбивается на набор небольших, слабо связанных сервисов, которые работают вместе для обеспечения общей функциональности системы. Вот некоторые плюсы и минусы микросервисов:

Плюсы:

1.  Масштабируемость: микросервисы позволяют независимо масштабировать отдельные компоненты приложения в зависимости от спроса, а не масштабировать все приложение целиком. Это упрощает обработку всплесков трафика или использования.
    
2.  Гибкость. Микросервисы упрощают внесение изменений в приложение, поскольку изменения в одном сервисе можно вносить, не затрагивая всю систему. Это также упрощает эксперименты с новыми функциями и технологиями.
    
3.  Изоляция сбоев: если один микросервис выходит из строя, это не обязательно приводит к остановке всего приложения. Это означает, что проблемы могут быть изолированы и решены быстрее.
    
4.  Разнообразие технологий. Микросервисы позволяют использовать разные технологии для разных сервисов, которые можно выбирать в зависимости от конкретных требований каждого сервиса.
    
5.  Автономные команды. Микросервисы позволяют автономным командам работать над разными сервисами независимо друг от друга, что может повысить производительность и упростить процесс разработки.

Минусы:

1.  Сложность. Микросервисы вносят дополнительную сложность, поскольку приходится управлять большим количеством движущихся частей. Это может затруднить сборку, развертывание и мониторинг приложения.
    
2.  Повышенная задержка. Поскольку микросервисы обмениваются данными по сети, существует возможность увеличения задержки по сравнению с монолитными приложениями, где все компоненты находятся в одном месте.
    
3.  Распределенное управление данными. При использовании микросервисов данные часто распределяются между несколькими сервисами, что усложняет управление и обеспечение согласованности.
    
4.  Тестирование. Тестирование становится более сложным для микросервисов, поскольку каждый сервис необходимо тестировать независимо, а также в сочетании с другими сервисами.
    
5.  Развертывание. Развертывание микросервисов может быть более сложным, чем развертывание монолитного приложения, поскольку требуется развертывание и управление большим количеством компонентов. 

В целом, микросервисы могут быть мощным инструментом для создания больших и сложных приложений, но для их эффективной реализации требуется тщательное рассмотрение и планирование.
