###  **Какие классы используются для управления потоками?**
`stub`
### Как установить приоритет потока?
В Java вы можете установить приоритет потока с помощью `setPriority()`метода. Класс `Thread`предоставляет постоянный набор значений приоритета в диапазоне от 1 (самый низкий приоритет) до 10 (самый высокий приоритет).
```java
Thread thread = new Thread(); 
thread.setPriority(Thread.MAX_PRIORITY);
```

###  **Что такое монитор (Monitor)?**
**Монитор — это конструкция синхронизации, которая позволяет потокам иметь как взаимное исключение (используя блокировки), так и сотрудничество,** то есть возможность заставить потоки ожидать выполнения определенного условия (используя  **wait-set**).

Язык программирования Java предоставляет несколько механизмов для связи между потоками. Самым основным из этих методов является _синхронизация_ , которая реализуется с помощью _мониторов_ . Каждый объект в Java связан с монитором, который поток может _блокировать_ или _разблокировать_ . Только один поток одновременно может удерживать блокировку на мониторе. Любые другие потоки, пытающиеся заблокировать этот монитор, блокируются до тех пор, пока они не смогут получить блокировку на этом мониторе. Поток _t_ может блокировать конкретный монитор несколько раз; каждая разблокировка отменяет эффект одной операции блокировки.

### **Каким образом можно синхронизировать доступ к общим ресурсам в Java?**
В Java вы можете синхронизировать доступ к общим ресурсам с помощью `synchronized` ключевого слова. Ключевое `synchronized` слово может быть применено к методу или блоку кода, чтобы гарантировать, что только один поток может выполнять этот метод или блок кода одновременно.

Вот пример использования `synchronized` ключевого слова для синхронизации доступа к общему ресурсу:
```java
public class SharedResource {
    private int counter;

    public synchronized void increment() {
        counter++;
    }
}
```

Вы также можете синхронизировать доступ к блоку кода с помощью `synchronized` ключевого слова, например:
```java
public class SharedResource {
    private Object lock = new Object();
    private int counter;

    public void increment() {
        synchronized(lock) {
            counter++;
        }
    }
}
```

Еще одним способом синхронизации доступа к общим ресурсам в Java является использование пакета `java.util.concurrent`, который предоставляет несколько потокобезопасных структур данных и механизмов синхронизации.

Одной из таких структур данных является `ConcurrentHashMap`, представляющая собой потокобезопасную реализацию интерфейса `Map`. Позволяет `ConcurrentHashMap`нескольким потокам одновременно читать и записывать карту без необходимости явной синхронизации. Вот пример:
```java
import java.util.concurrent.ConcurrentHashMap;

public class SharedResource {
    private ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

    public void increment(String key) {
        map.put(key, map.getOrDefault(key, 0) + 1);
    }
}
```

Другим механизмом синхронизации, предоставляемым пакетом, `java.util.concurrent`является `Lock`интерфейс, который обеспечивает более точное управление синхронизацией, чем `synchronized`ключевое слово. Вот пример:
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
    private Lock lock = new ReentrantLock();
    private int counter;

    public void increment() {
        lock.lock();
        try {
            counter++;
        } finally {
            lock.unlock();
        }
    }
}

```

### **Как устроен механизм сигналов (Signals) в Java?**
`stub--------------------------stub`

###   **Что такое Deadlock в Java? Как его избежать?**
`stub--------------------------stub`

###   **Как устроен механизм прерывания (Interrupts) в Java?**
[[JAVA interrupt (method)]]

###   **Как можно использовать классы Lock и Condition в Java?**
Классы Lock и Condition в Java предоставляют альтернативу использованию синхронизированных блоков и методов для управления доступом к общим ресурсам в многопоточных программах. Интерфейс Lock обеспечивает более гибкий способ получения и снятия блокировок, а интерфейс Condition позволяет потокам ожидать выполнения определенных условий.

Вот пример использования классов Lock и Condition в Java:
```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private int count = 0;

    public void increment() throws InterruptedException {
        lock.lock();
        try {
            while (count == 10) {
                condition.await();
            }
            count++;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                condition.await();
            }
            count--;
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

В этом примере `SharedResource`класс имеет `count`переменную, представляющую общий ресурс. Методы `increment`и `decrement`используют `Lock`объект, чтобы гарантировать, что только один поток может изменять `count`переменную за раз.

Методы `await`и `signalAll`объекта `Condition`используются для управления потоком выполнения между потоками. Метод `await`заставляет вызывающий поток ждать, пока `signalAll`метод не будет вызван для того же `Condition`объекта. Метод `signalAll`пробуждает все потоки, ожидающие объект `Condition`.

Блок `finally`используется для снятия блокировки даже в случае возникновения исключения, гарантируя, что блокировка всегда снимается должным образом.

В целом, классы Lock и Condition можно использовать для обеспечения более гибкого и детального подхода к синхронизации в многопоточных программах, позволяющего лучше контролировать выполнение потоков и использование общих ресурсов.

###   **Что такое AtomicInteger в Java?**
AtomicInteger — это класс в пакете Java `java.util.concurrent.atomic`, который обеспечивает потокобезопасный способ выполнения атомарных операций над целочисленной переменной. Класс предоставляет несколько методов для выполнения операций над базовым целочисленным значением, обеспечивая при этом атомарность операций и синхронизацию между потоками.

Наиболее часто используемые методы класса AtomicInteger:

1.  `get()`: возвращает текущее значение AtomicInteger.
    
2.  `set(int newValue)`: устанавливает значение AtomicInteger в заданное значение.
    
3.  `getAndSet(int newValue)`: атомарно устанавливает значение AtomicInteger в заданное значение и возвращает предыдущее значение.
    
4.  `incrementAndGet()`: атомарно увеличивает значение AtomicInteger и возвращает новое значение.
    
5.  `decrementAndGet()`: атомарно уменьшает значение AtomicInteger и возвращает новое значение.
    
6.  `getAndIncrement()`: атомарно увеличивает значение AtomicInteger и возвращает предыдущее значение.
    
7.  `getAndDecrement()`: атомарно уменьшает значение AtomicInteger и возвращает предыдущее значение.
    
8.  `compareAndSet(int expect, int update)`: атомарно устанавливает значение AtomicInteger в заданное значение обновления, если текущее значение равно заданному ожидаемому значению. Возвращает true, если обновление прошло успешно, иначе false.
    

Эти методы полезны для реализации потокобезопасных алгоритмов и структур данных, когда нескольким потокам может потребоваться одновременное изменение или чтение одного и того же целочисленного значения. Используя AtomicInteger, программист может гарантировать, что эти операции выполняются атомарно, без необходимости явной блокировки или синхронизации.

###   **Какие методы можно использовать для ожидания завершения выполнения потока в Java?**
Wait для ожидания и interrupt для завершения выполнения.


###   **Какие виды синхронизации потоков есть в Java?**
В Java существует несколько видов механизмов синхронизации потоков, в том числе:

1.  Синхронизированные методы и блоки. Синхронизированные методы и блоки используют неявные блокировки, чтобы гарантировать, что только один поток может одновременно получить доступ к общему ресурсу или критической части кода. Когда поток входит в синхронизированный метод или блок, он получает блокировку для связанного с ним объекта, и ни один другой поток не может войти в тот же синхронизированный метод или блок, пока блокировка не будет снята.
    
2.  ReentrantLock: класс ReentrantLock предоставляет альтернативу синхронизированным методам и блокам, которая обеспечивает более явное управление блокировкой. ReentrantLock предоставляет несколько методов получения и снятия блокировок, а также дополнительные функции, такие как политики справедливости и ожидание по времени.
    
3.  Семафоры. Семафоры — это механизм синхронизации, который позволяет нескольким потокам одновременно обращаться к общему ресурсу, но с ограниченным числом потоков, которым разрешен доступ к ресурсу в любой момент времени. Семафоры можно использовать для управления доступом к ресурсу с ограниченной емкостью, например к пулу соединений с базой данных.
    
4.  CountDownLatch: класс CountDownLatch предоставляет механизм синхронизации, который позволяет одному или нескольким потокам ожидать определенного количества событий, прежде чем продолжить. CountDownLatch часто используется для координации запуска нескольких потоков в параллельной программе.
    
5.  CyclicBarrier: класс CyclicBarrier предоставляет механизм синхронизации, который позволяет нескольким потокам ждать, пока друг друга не достигнут определенной точки, прежде чем продолжить. CyclicBarrier часто используется для координации выполнения нескольких потоков в параллельной программе.
    
6.  ReadWriteLock. Интерфейс ReadWriteLock позволяет реализовать эффективный и безопасный одновременный доступ к общим ресурсам, которые в основном доступны только для чтения. ReadWriteLock обеспечивает две блокировки, одну для чтения и одну для записи, и позволяет нескольким потокам одновременно читать ресурс, но гарантирует, что только один поток может одновременно писать в ресурс.
    

В целом, в Java доступно множество различных механизмов синхронизации потоков, каждый из которых имеет свои сильные и слабые стороны. Важно выбрать соответствующий механизм синхронизации для конкретных требований вашей параллельной программы.

###   **Что такое блокировка (Locking) в Java?**
Блокировка в Java — это механизм, который обеспечивает потокобезопасный доступ к общим ресурсам, позволяя потокам устанавливать и снимать блокировки объектов или ресурсов. Блокировка используется для обеспечения того, чтобы только один поток мог получить доступ к общему ресурсу или критической части кода одновременно, тем самым предотвращая условия гонки и обеспечивая правильное поведение многопоточных программ.

Java предоставляет несколько механизмов блокировки, в том числе:

1.  Синхронизированные блоки. Синхронизированные блоки позволяют синхронизировать блок кода с конкретным объектом. Когда поток входит в синхронизированный блок, он получает блокировку для связанного с ним объекта, и ни один другой поток не может войти в тот же синхронизированный блок, пока блокировка не будет снята.
    
2.  Синхронизированные методы. Синхронизированные методы аналогичны синхронизированным блокам, но применяются ко всем методам. Когда поток входит в синхронизированный метод, он получает блокировку для связанного объекта, и ни один другой поток не может войти в тот же метод, пока блокировка не будет снята.
    
3.  ReentrantLock: класс ReentrantLock предоставляет более гибкий механизм блокировки, чем синхронизированные блоки и методы. ReentrantLock позволяет явно устанавливать и снимать блокировки и предоставляет дополнительные функции, такие как ожидание по времени, прерываемое ожидание и политики справедливости.
    
4.  ReadWriteLock. Интерфейс ReadWriteLock позволяет реализовать эффективный и безопасный одновременный доступ к общим ресурсам, которые в основном доступны только для чтения. ReadWriteLock обеспечивает две блокировки, одну для чтения и одну для записи, и позволяет нескольким потокам одновременно читать ресурс, но гарантирует, что только один поток может одновременно писать в ресурс.
    

В общем, блокировка является важным понятием в параллельном программировании, и важно использовать ее правильно, чтобы обеспечить правильное поведение многопоточных программ Java.

###   **Что такое взаимное исключение (Mutual Exclusion) в Java?**
Взаимное исключение — это свойство параллельных программ, в котором только один поток в каждый момент времени может получить доступ к общему ресурсу или критической части кода. В Java взаимное исключение достигается за счет использования механизмов синхронизации, таких как синхронизированные методы, синхронизированные блоки и блокировки.

Когда несколько потоков пытаются одновременно получить доступ к общему ресурсу, могут возникнуть условия гонки. Эти условия гонки могут вызвать непоследовательное поведение, повреждение данных или даже сбой программы. Взаимное исключение гарантирует, что только один поток может получить доступ к общему ресурсу одновременно, предотвращая условия гонки и обеспечивая согласованное поведение программы.

В Java взаимное исключение обычно достигается за счет использования блокировок, которые позволяют потоку получать эксклюзивный доступ к общему ресурсу. Когда поток получает блокировку, ни один другой поток не может получить такую ​​же блокировку, пока первый поток не освободит ее. Это гарантирует, что только один поток может получить доступ к общему ресурсу одновременно.

В дополнение к блокировкам Java также предоставляет другие механизмы синхронизации, такие как синхронизированные методы и синхронизированные блоки, которые позволяют синхронизировать доступ к критическим разделам кода. Синхронизированные методы и блоки используют неявные блокировки, связанные с объектом, в котором определен метод или блок.

В целом взаимное исключение — важная концепция параллельного программирования, необходимая для обеспечения корректности многопоточных программ Java, обращающихся к общим ресурсам.

###   **Как можно использовать синхронизированные методы и блоки для синхронизации потоков в Java?**
Синхронизированные методы и блоки используются для предотвращения одновременного доступа нескольких потоков к общим ресурсам или критическим разделам кода.

В Java вы можете использовать `synchronized`ключевое слово для создания синхронизированных методов и блоков.

1.  Синхронные методы:

Чтобы создать синхронизированный метод, вам просто нужно добавить `synchronized`ключевое слово в сигнатуру метода. Когда поток входит в синхронизированный метод, он получает блокировку для объекта, которому принадлежит этот метод, и никакой другой поток не может войти в любой другой синхронизированный метод того же объекта, пока блокировка не будет снята.

Например:
```java
public synchronized void myMethod() {
   // Critical section of code
}
```
В приведенном выше примере `myMethod()`метод синхронизирован, и одновременно его может выполнять только один поток.

2.  Синхронизированные блоки:

Синхронизированные блоки позволяют синхронизировать определенный блок кода, а не весь метод. Чтобы создать синхронизированный блок, вам нужно указать объект, который вы хотите синхронизировать, а затем заключить критическую часть кода в синхронизируемый блок.

Например:
```java
public void myMethod() {
   // Non-critical section of code
   
   synchronized (this) {
      // Critical section of code
   }
   
   // Non-critical section of code
}
```

В приведенном выше примере критический раздел кода в синхронизированном блоке синхронизируется с объектом `this`. Когда поток входит в синхронизированный блок, он получает блокировку для `this`объекта, и ни один другой поток не может войти в тот же синхронизированный блок, пока блокировка не будет снята.

###   **Что такое Wait/Notify в Java? Как они работают?**
`stub--------------------------stub`

###   **Какой класс используется для выполнения отложенных задач в многопоточной среде в Java?**
`stub--------------------------stub`

###  **Как можно использовать Executors и ExecutorService в Java?**
`stub--------------------------stub`

###   **Как можно создать и управлять пулом потоков (Thread Pool) в Java?**
`stub--------------------------stub`

###   **Как работает механизм ThreadLocal?**
`stub--------------------------stub`

###   **Как можно использовать Semaphore и CountDownLatch в Java?**
`stub--------------------------stub`

###   **Как устроен механизм Fork/Join в Java? Как он используется для параллельной обработки данных?**
`stub--------------------------stub`

###   **Как можно измерить производительность и эффективность многопоточного приложения в Java?**
`stub--------------------------stub`

###   **Какие существуют проблемы и ограничения при работе с потоками в Java?**
`stub--------------------------stub`

###  **Как можно использовать класс Phaser в Java для синхронизации потоков?**
`stub--------------------------stub`

###   **Как можно создать собственную реализацию блокировки (Lock) в Java?**
`stub--------------------------stub`

###   **Что такое Non-Blocking алгоритмы? Как они используются для реализации конкурентности в Java?**
`stub--------------------------stub`

###  **Как устроен механизм ForkJoinPool в Java? Как он используется для параллельной обработки данных?**
`stub--------------------------stub`

###  **Что такое Data Race? Как его избежать?**
`stub--------------------------stub`

###   **Что такое Wait-Free алгоритмы? Как они используются для реализации конкурентности в Java?**
`stub--------------------------stub`
