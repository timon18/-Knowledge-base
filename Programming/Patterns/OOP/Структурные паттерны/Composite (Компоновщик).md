28-03-2023
11:08
Authors: 
***
Tags: #patterns 
***
# Компоновщик
Также известен как: Дерево, Composite

>**Компоновщик** — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.
>(https://refactoring.guru/ru/design-patterns/composite)

> Компонует объекты в древовидные структуры для представления иерархий «часть — целое». Позволяет клиентам единообразно трактовать индивидуальные и составные объекты.
> (Паттерны объектно-ориентированного программирования 2020. GoF)

## Проблема.
Некоторые объекты могут быть составными и состоять из других объектов, при этом клиенты могут работать с каждым объектом по-разному. Требуется разработать структуру, которая позволит работать с каждым объектом единообразно и обращаться к составным объектам так же, как и к их частям

## Решение
Паттерн Composite предлагает создать иерархию объектов, где каждый объект может быть как простым, так и составным. Каждый объект реализует общий интерфейс, что позволяет клиентам работать с ними единообразно. Составные объекты содержат ссылки на другие объекты того же интерфейса, что позволяет обращаться к ним так же, как и к простым объектам.

## Пример
Предположим, у нас есть класс "Файл" (File), который представляет собой файл в файловой системе. У нас также есть класс "Директория" (Directory), который состоит из файлов и других директорий. Иерархия классов выглядит следующим образом:
```java
interface FileSystemItem {
    String getName();
    void ls();
}

class File implements FileSystemItem {
    private String name;
    
    public File(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void ls() {
        System.out.println(getName());
    }
}

class Directory implements FileSystemItem {
    private String name;
    private List<FileSystemItem> items;
    
    public Directory(String name) {
        this.name = name;
        items = new ArrayList<>();
    }
    
    public void add(FileSystemItem item) {
        items.add(item);
    }
    
    public String getName() {
        return name;
    }
    
    public void ls() {
        System.out.println(getName());
        for (FileSystemItem item : items) {
            item.ls();
        }
    }
}
```
Здесь классы `File` и `Directory` реализуют общий интерфейс `FileSystemItem`, который включает методы `getName()` и `ls()`. Класс `Directory` содержит список элементов, которые могут быть как файлами, так и другими директориями. Метод `ls()` класса `Directory` вызывает метод `ls()` для каждого элемента, что позволяет обращаться к составным объектам так же, как и к их частям.